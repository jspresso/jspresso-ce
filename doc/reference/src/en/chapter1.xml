<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="chapter1">
  <title>Getting started</title>

  <para>This chapter will help you to understand the basics of the
  <trademark>D2S</trademark> application framework and how to work with
  it.</para>

  <section>
    <title>The human resources (HR) sample application</title>

    <para>The human resources application is a simple yet comprehensive
    business application targeted at managing a company organization and the
    employees who work in it. It will demonstrate how
    <trademark>D2S</trademark> can handle a domain model with its
    relationships and its constraints, present it to the end-user for
    manipulation through various built-in views and actions, handle security
    through profile management, distribute the frontend across the network,
    ...</para>

    <section>
      <title>The domain model</title>

      <para>To quickly introduce the HR domain model, let's dive into the
      following UML class diagrams. As a general rule to make the diagrams
      more readable attributes must in fact be considered as getter / setter
      pairs.</para>

      <para>The <link linkend="commons-cd">commons class diagram</link>
      describes commonly used interfaces and classes.</para>

      <para>A few hints :</para>

      <itemizedlist>
        <listitem>
          <para>The traceable interface is implemented by entities for which
          we need to record when it was saved for the first time and when it
          was last updated. Of course, these tracing elements must be made
          read-only to the end-user since they are automatically managed by
          the application.</para>
        </listitem>

        <listitem>
          <para>The nameable is implemented by entities having a name. A name
          has a max length of 64 characters and is mandatory. Nameable
          implements a service which formats its name (a really simple service
          only for demonstration purpose).</para>
        </listitem>

        <listitem>
          <para>The contact information component is used by entities that
          have contact details (address, phone, email, ...). A contact
          information points to one and only one city. A city is nameable and
          has a zip code of maximum length 10 characters.</para>
        </listitem>

        <listitem>
          <para>An event is a piece of text which is traceable</para>
        </listitem>
      </itemizedlist>

      <figure id="commons-cd">
        <title>Commons class diagram</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="60%"
                       fileref="../images/commons-cd.png" scalefit="1"
                       width="100%" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>The <link linkend="employee-cd">employees class diagram</link>
      describes what an employee is.</para>

      <para>A few hints :</para>

      <itemizedlist>
        <listitem>
          <para>An employee is nameable and traceable. An employee has
          :</para>

          <itemizedlist>
            <listitem>
              <para>a first name (his last name is inherited by the nameable
              interface)</para>
            </listitem>

            <listitem>
              <para>a social security number which is composed by exactly 10
              digits and which is unique among all employees</para>
            </listitem>

            <listitem>
              <para>a gender (male or female)</para>
            </listitem>

            <listitem>
              <para>a birth date</para>
            </listitem>

            <listitem>
              <para>a hire date in the company</para>
            </listitem>

            <listitem>
              <para>a contact information</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>

      <itemizedlist>
        <listitem>
          <para>An employee must provide a method to compute his age based on
          his birth date.</para>
        </listitem>

        <listitem>
          <para>An employee has an ordered list of events.</para>
        </listitem>
      </itemizedlist>

      <figure id="employee-cd">
        <title>Employees class diagram</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="60%"
                       fileref="../images/employees-cd.png" scalefit="1"
                       width="100%" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>The <link linkend="organization-cd">organization class
      diagram</link> describes how the company is structured in departments
      and teams.</para>

      <para>A few hints :</para>

      <itemizedlist>
        <listitem>
          <para>A company is structured in organizational units. An
          organizational unit may be a department or a team. An organizational
          unit has an identifier (<emphasis>ouId</emphasis>) which is formed
          by a 2 letter code followed by a dash followed by a 3 digit number
          (<emphasis>IS-001</emphasis> for instance). Each organizational unit
          has a manager who is an employee of the company it belongs to. An
          employee can at most manage one organizational unit. An
          organizational unit is nameable, traceable and has contact
          information as well as a company has.</para>
        </listitem>

        <listitem>
          <para>The company may have one or more departments and a department
          belongs to one and only one company.</para>
        </listitem>

        <listitem>
          <para>A department may have one or more teams and a team belongs to
          one and only one department. Each team is composed by one or more
          employees.</para>
        </listitem>

        <listitem>
          <para>An employee belongs to one and only one company. An employee
          may belong to zero or more teams.</para>
        </listitem>
      </itemizedlist>

      <figure id="organization-cd">
        <title>Organization class diagram</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="60%"
                       fileref="../images/organization-cd.png" scalefit="1"
                       width="100%" />
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>The application modules</title>

      <para>The HR application is divided in 3 modules.</para>

      <section>
        <title>The organization management module</title>

        <para>This module manages a company structure in terms of
        organizational units. The end-user may create/delete/update a company,
        create/delete/update its organizational units and structure them in
        the organization. The end-user may compose the employee teams, assign
        an organisational unit manager but won't be able to
        create/update/delete an employee. The organization must be displayed
        in a hierarchical (tree) view.</para>
      </section>

      <section>
        <title>The employees management module</title>

        <para>This module manages a company staff. The end-user can retrieve
        the company employees and create/update/delete an employee. The
        end-user will be able to create/update/delete events for an employee
        and may re-order them in an unspecified manner as needed.</para>
      </section>

      <section>
        <title>The master data management module</title>

        <para>This module manages the application master data. As of now, the
        master data are only made of the cities available to compose the
        addresses.</para>
      </section>
    </section>

    <section>
      <title>The profiles</title>

      <para>The HR application offers 3 profiles.</para>

      <section>
        <title>The organization manager profile</title>

        <para>A logged-in user having the organization manager profile will be
        granted access to the organization management module as well as the
        master data management module but he won't be able to create a new
        company.</para>
      </section>

      <section>
        <title>The staff manager profile</title>

        <para>A logged-in user having the staff manager profile will be
        granted access to the employee management module as well as the master
        data management module but he won't be able to re-order the events
        assigned to an employee.</para>
      </section>

      <section>
        <title>The administrator profile</title>

        <para>The administrator profile has no restriction in the
        application.</para>
      </section>
    </section>
  </section>

  <section>
    <title>Layering the application</title>

    <para>Now that we have collected the detailed specifications, it's time to
    feed the framework with them. As we saw before, most of the job will
    consist in describing the different layers in a structured way. But before
    going further, let's define the best practices regarding the logical
    layering of a typical <trademark>D2S</trademark> application (although
    these practices may generally apply to any well designed application). We
    will define 3 logical layers from the bottom to the top :</para>

    <itemizedlist>
      <listitem>
        <para>The domain model</para>
      </listitem>

      <listitem>
        <para>The backend</para>
      </listitem>

      <listitem>
        <para>The frontend</para>
      </listitem>
    </itemizedlist>

    <para>This organisation will help to prevent cyclic dependencies between
    layers since each layer will be allowed to use lower ones but not higher
    ones (e.g. : the backend may use the domain model but not the
    frontend).</para>

    <para>Of course, this is a minimal logical layering. Each of this layer
    may be further divided in subparts depending on the software complexity.
    For instance the domain model might be divided in master and movement data
    and the backend and frontend may be divided in modules. It's entirely up
    to the application designer to tailor these rules. But it surely is the
    first design activity.</para>

    <para>The <link linkend="general-cod">general architecture diagram</link>
    introduces this layering strategy.</para>

    <figure id="general-cod">
      <title>General architecture diagram</title>

      <mediaobject>
        <imageobject>
          <imagedata contentdepth="60%" fileref="../images/general-cod.png"
                     scalefit="1" width="100%" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>Let's define now what precisely go in these layers.</para>

    <section>
      <title>The domain model</title>

      <para>The domain model includes :</para>

      <itemizedlist>
        <listitem>
          <para>The entities. An entity will be described by :</para>

          <itemizedlist>
            <listitem>
              <para>properties along with their constraints and their
              interceptors</para>
            </listitem>

            <listitem>
              <para>behaviour (business methods, life-cycle
              interceptors)</para>
            </listitem>

            <listitem>
              <para>integrity enforcements</para>
            </listitem>

            <listitem>
              <para>default presentation elements (name, icon, rendered
              properties, ordering properties)</para>
            </listitem>

            <listitem>
              <para>relationships to other entities (cardinality,
              reversibility)</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>The components. A component has all the characteristics of an
          entity except that it is not autonomous since It is designed as a
          structure to be inlined in an entity (e.g. : an address
          structure).</para>
        </listitem>

        <listitem>
          <para>Other structural elements like common business
          interfaces.</para>
        </listitem>
      </itemizedlist>

      <para>We will see later that there virtually any domain model can be
      extensively described using <trademark>D2S</trademark>. This includes
      for instance polymorphic entities or associations, multiple inheritance,
      and so on.</para>
    </section>

    <section>
      <title>The backend</title>

      <para>The backend includes all the application parts that do not depend
      on the client :</para>

      <itemizedlist>
        <listitem>
          <para>The actions server parts (which interact with the domain model
          for instance)</para>
        </listitem>

        <listitem>
          <para>The application modules along with their hierarchies of
          sub-modules. A module is a top application entry point which is
          directly accessible by the end user.</para>
        </listitem>

        <listitem>
          <para>The application sub-modules. They form a hierarchy since
          sub-modules may contain other sub-modules. Each sub-module is an
          independent application part targeted at accessing the backend data
          (domain model manipulation, reporting, ...).</para>
        </listitem>

        <listitem>
          <para>The backend controller which holds the user backend
          application state and its configuration (application modules
          registration)</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>The frontend</title>

      <para>The frontend includes all the application parts that interact
      directly with the end-user :</para>

      <itemizedlist>
        <listitem>
          <para>The views</para>
        </listitem>

        <listitem>
          <para>The action client parts (which handle user interaction and
          trigger action server parts)</para>
        </listitem>

        <listitem>
          <para>The client application module parts</para>
        </listitem>

        <listitem>
          <para>The frontend controller which holds the user frontend
          application state and its configuration (client application modules
          registration)</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section>
    <title>Describing the domain model</title>

    <para>In this chapter, you will learn how to feed the
    <trademark>D2S</trademark> framework with the sample domain model
    description.</para>

    <section>
      <title>Using the Spring dependency injection container</title>

      <para>Let's go back to the HR sample application. As for every layer
      introduced above, describing the domain model will consist in assembling
      <trademark>D2S</trademark> description java beans using the <ulink
      url="http://www.springframework.org/">Spring framework Dependency
      Injection Container</ulink>. To achieve this, you will have to write an
      XML file that conforms to the <ulink
      url="http://www.springframework.org/schema/beans/spring-beans-2.0.xsd">spring
      beans schema</ulink>. Of course, you can use any text editor but we will
      encourage you to use at least a schema-aware XML editor like <ulink
      url="http://www.jedit.org/">jEdit</ulink> or even better, use <ulink
      url="http://www.eclipse.org/">Eclipse</ulink> and <ulink
      url="http://springide.org/project/wiki/SpringideInstall">Spring
      IDE</ulink>. The latest will offer a lot of productivity enhancement
      with code completion for the XML elements and attributes as well as for
      the description bean class names and properties of
      <trademark>D2S</trademark>.</para>

      <para>The various description java beans that are provided by
      <trademark>D2S</trademark> are detailed in the next chapter.</para>

      <para>We will use the root package
      <code>com.d2s.framework.hrsample</code> for our application. The domain
      model description will logically go to the
      <code>com.d2s.framework.hrsample.model</code> package. In this package,
      we will create a <filename>hrsample-model.xml</filename> file as
      described below :</para>

      <programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans
  xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.springframework.org/schema/beans
                      http://www.springframework.org/schema/beans/spring-beans-2.0.xsd"
  default-lazy-init="true"&gt;

&lt;/beans&gt;</programlisting>
    </section>

    <section>
      <title>Interfaces</title>

      <para>As a starting point, we will describe the <link
      linkend="commons-cd">commons</link> model part.</para>

      <para>The <code>Nameable</code> interface may be described as follow
      :</para>

      <programlisting language="xml">&lt;bean <co id="n-bean" />
  id="Nameable" <co id="n-id" />
  class="com.d2s.framework.model.descriptor.basic.BasicInterfaceDescriptor"&gt; <co
          id="n-class" />
  &lt;constructor-arg
    value="com.d2s.framework.hrsample.model.Nameable" /&gt; <co
          id="n-classname" />
  &lt;property name="propertyDescriptors"&gt; <co id="n-props" />
    &lt;list&gt;
      &lt;bean
        class="com.d2s.framework.model.descriptor.basic.BasicStringPropertyDescriptor"&gt;<co
          id="n-stringprop" />
        &lt;property
          name="name" <co id="n-name" />
          value="name" /&gt;
        &lt;property
          name="maxLength" <co id="n-maxl" />
          value="64" /&gt;
        &lt;property
          name="mandatory" <co id="n-mand" />
          value="true" /&gt;
      &lt;/bean&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting>

      <calloutlist>
        <callout arearefs="n-bean">
          <para>This is a standard spring bean definition. We are creating a
          descriptor bean.</para>
        </callout>

        <callout arearefs="n-id">
          <para>The identifier of this descriptor bean instance for later
          reference.</para>
        </callout>

        <callout arearefs="n-class">
          <para>Since we are describing a generic interface (which may or may
          not turn to be an entity) we will use a
          <code>BasicInterfaceDescriptor</code> as opposed to a
          <code>BasicEntityDescriptor</code> or
          <code>BasicComponentDescriptor</code>.</para>
        </callout>

        <callout arearefs="n-classname">
          <para>The (fully-qualified) name of this interface.</para>
        </callout>

        <callout arearefs="n-props">
          <para>The property descriptors of this interface descriptor.</para>
        </callout>

        <callout arearefs="n-stringprop">
          <para>The string property descriptor to hold the <code>name</code>
          property description.</para>
        </callout>

        <callout arearefs="n-name">
          <para>The name of the <code>name</code> property which is
          "name".</para>
        </callout>

        <callout arearefs="n-maxl">
          <para>The maximum length of the name property which is 64
          characters.</para>
        </callout>

        <callout arearefs="n-mand">
          <para>The fact that the <code>name</code> property is mandatory on a
          <code>Nameable</code>.</para>
        </callout>
      </calloutlist>

      <para>As you can see above, we create an interface descriptor
      (<code>com.d2s.framework.sample.backend.domain.Nameable</code>) with one
      property (<code>name</code>) along with its constraints
      (<code>maxLength</code> and <code>mandatory</code>). This is a fairly
      simple interface since it has no intrinsic behaviour nor relationships
      with other components.</para>

      <para>So now, lets describe the <code>Traceable</code> interface as
      follow :</para>

      <programlisting language="xml">&lt;bean
  id="Traceable"
  class="com.d2s.framework.model.descriptor.basic.BasicInterfaceDescriptor"&gt;
  &lt;constructor-arg value="com.d2s.framework.hrsample.model.Traceable" /&gt;
  &lt;property name="propertyDescriptors"&gt;
    &lt;list&gt;
      &lt;bean
        class="com.d2s.framework.model.descriptor.basic.BasicDatePropertyDescriptor"&gt; <co
          id="t-createTimestamp" />
        &lt;property
          name="name"
          value="createTimestamp" /&gt;
        &lt;property
          name="type"
          ref="DATE_TIME" /&gt; <co id="t-DATE_TIME" />
        &lt;property
          name="readOnly"
          value="true" /&gt; <co id="readOnly" />
      &lt;/bean&gt;
      &lt;bean
        class="com.d2s.framework.model.descriptor.basic.BasicDatePropertyDescriptor"&gt;
        &lt;property
          name="name"
          value="lastUpdateTimestamp" /&gt;
        &lt;property
          name="type"
          ref="DATE_TIME" /&gt;
        &lt;property
          name="readOnly"
          value="true" /&gt;
      &lt;/bean&gt;
    &lt;/list&gt;
  &lt;/property&gt;
  &lt;property name="unclonedProperties"&gt; <co id="t-uncloned" />
    &lt;list&gt;
      &lt;value&gt;createTimestamp&lt;/value&gt;
      &lt;value&gt;lastUpdateTimestamp&lt;/value&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting>

      <calloutlist>
        <callout arearefs="t-createTimestamp">
          <para>The date property descriptor to hold the
          <code>createTimestamp</code> property. Same applies for the
          <code>lastUpdateTimestamp</code> property.</para>
        </callout>

        <callout arearefs="t-DATE_TIME">
          <para>We want to preserve date and time information in this property
          (<code>DATE_TIME</code> constant). The alternative would have been
          to round the property and loose the time precision; in that case, we
          would have used the <code>DATE</code> constant.</para>
        </callout>

        <callout arearefs="readOnly">
          <para>We don't want this property to be updatable by the end user so
          we make it read-only.</para>
        </callout>

        <callout arearefs="t-uncloned">
          <para>Whenever a <code>Traceable</code> component is duplicated, we
          want exclude the tracing values from the cloning process.</para>
        </callout>
      </calloutlist>

      <para>The <code>Traceable</code> interface description is slightly more
      complicated than the <code>Nameable</code> interface since not all
      properties are eligible to cloning
      (<code>unclonedProperties</code>).</para>
    </section>

    <section>
      <title>Generating the code</title>

      <para>It is time now to get our interfaces generated before going
      further. Let's use the <trademark>D2S</trademark> generation tool to
      make it happen. <trademark>D2S</trademark> provides a <ulink
      url="http://freemarker.org/">freemarker</ulink> template to generate the
      components that may be easily triggered using a simple ant task. Since
      this generator explores the spring beans definitions, we first need to
      declare our <filename>hrsample-model.xml</filename> as being part of our
      application. To achieve that, let's create a configuration file named
      <filename><code>beanRefFactory.xml</code></filename> in the root source
      folder (without any package) as follow :</para>

      <para><programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans
  xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.springframework.org/schema/beans
                      http://www.springframework.org/schema/beans/spring-beans-2.0.xsd"
  default-lazy-init="true"&gt;

  &lt;bean
    id="hrsample-model-context"
    class="org.springframework.context.support.ClassPathXmlApplicationContext"
    lazy-init="true"&gt;
    &lt;constructor-arg&gt;
      &lt;list&gt;
        &lt;value&gt;com/d2s/framework/application/commons.xml&lt;/value&gt; <co
            id="brf-commons" />
        &lt;value&gt;com/d2s/framework/tools/mock.xml&lt;/value&gt; <co
            id="brf-mock" />
        &lt;value&gt;com/d2s/framework/hrsample/model/hrsample-model.xml&lt;/value&gt; <co
            id="brf-model" />
      &lt;/list&gt;
    &lt;/constructor-arg&gt;
  &lt;/bean&gt;
&lt;/beans&gt;</programlisting><calloutlist>
          <callout arearefs="brf-commons">
            <para>The commons bean definitions of the
            <trademark>D2S</trademark> framework.</para>
          </callout>

          <callout arearefs="brf-mock">
            <para>A configuration file that contain necessary but yet
            undefined (for the moment) application bean references; this file
            is only used for the component generation phase.</para>
          </callout>

          <callout arearefs="brf-model">
            <para>Our application model description file.</para>
          </callout>
        </calloutlist>This configuration file assembles the necessary spring
      configuration files for the generator to operate. So we are ready to
      operate the generator using the following build.xml ant file :</para>

      <programlisting language="xml">&lt;?xml version="1.0"?&gt;

&lt;project default="all"&gt;

  &lt;property file="build.properties" /&gt;
  &lt;property name="xdoclet.lib.dir" value="${xdoclet.home}/lib" /&gt;
  &lt;property name="xdoclet.plugins.dir" value="${xdoclet.home}/plugins" /&gt;

  &lt;property name="src.dir" value="${basedir}/src/main" /&gt;
  &lt;property name="java.src.dir" value="${src.dir}/java" /&gt;
  &lt;property name="resources.src.dir" value="${src.dir}/resources" /&gt;
  &lt;property name="ddl.dir" value="${src.dir}/ddl" /&gt;

  &lt;path id="entity.generator.classpath"&gt;
    &lt;dirset dir="${basedir}"&gt;
      &lt;include name="**/target/classes" /&gt;
    &lt;/dirset&gt;
    &lt;fileset dir="${m2.repo}"&gt;
      &lt;include name="**/design2see/**/2.0/*.jar" /&gt;
      &lt;include name="**/commons-cli-1.0.jar" /&gt;
      &lt;include name="**/freemarker-2.3.3.jar" /&gt;
      &lt;include name="**/spring-2.0.6.jar" /&gt;
      &lt;include name="**/commons-logging-1.1.jar" /&gt;
      &lt;include name="**/xml-apis-2.0.2.jar" /&gt;
      &lt;include name="**/xerces-2.0.2.jar" /&gt;
      &lt;include name="**/bsf-2.3.0.jar" /&gt;
      &lt;include name="**/commons-beanutils-1.7.0.jar" /&gt;
    &lt;/fileset&gt;
  &lt;/path&gt;

  &lt;target name="generate-entities"&gt;
    &lt;java classname="com.d2s.framework.tools.entitygenerator.EntityGenerator"
          classpathref="entity.generator.classpath"&gt;
      &lt;arg value="-applicationContextKey" /&gt;
      &lt;arg value="hrsample-model-context" /&gt;
      &lt;arg value="-templateResourcePath" /&gt;
      &lt;arg value="/com/d2s/framework/tools/entitygenerator" /&gt;
      &lt;arg value="-templateName" /&gt;
      &lt;arg value="HibernateXdocletEntity.ftl" /&gt;
      &lt;arg value="-outputDir" /&gt;
      &lt;arg value="${java.src.dir}" /&gt;
      &lt;arg value="-includePackages" /&gt;
      &lt;arg value="com.d2s.framework.hrsample.model" /&gt;
    &lt;/java&gt;
  &lt;/target&gt;

  &lt;target name="all" depends="generate-entities" /&gt;

&lt;/project&gt;</programlisting>

      <para>You may now have a look into the
      <code>com.d2s.framework.hrsample.model</code> package source directory.
      You may find the 2 generated classes :</para>

      <itemizedlist>
        <listitem>
          <para><filename>Nameable.java</filename> for the Nameable interface
          (see the <link linkend="Nameable">source code below</link>).</para>
        </listitem>

        <listitem>
          <para><filename>Traceable.java</filename> for the Traceable
          interface.</para>
        </listitem>
      </itemizedlist>

      <programlisting id="Nameable" language="java">package com.d2s.framework.hrsample.model;

/**
 * Nameable component.
 * &lt;p&gt;
 * Generated by Design2see. All rights reserved.
 * &lt;p&gt;
 *
 * @author Generated by Design2see
 * @version $LastChangedRevision$
 */
public interface Nameable {

  /**
   * Gets the name.
   *
   * @hibernate.property
   * @hibernate.column
   *           name = "NAME"
   *           length = "64"
   *           not-null = "true"
   * @return the name.
   */
  java.lang.String getName();

  /**
   * Sets the name.
   *
   * @param name
   *          the name to set.
   */
  void setName(java.lang.String name);

}</programlisting>

      <para>These 2 java classes are in fact interfaces with getters and
      setters for the declared properties. In fact, you will never need any
      implementation for them since <trademark>D2S</trademark> will
      automatically handle their implementation for you at runtime using J2SE
      proxies. This approach relieves the developer from writing the
      implementation classes and thus, improves quality, robustness and
      productivity.</para>

      <para>You may also notice that the generator took care of annotating the
      classes with <ulink url="http://www.hibernate.org/">hibernate</ulink>
      <ulink
      url="http://xdoclet.sourceforge.net/xdoclet/index.html">xDoclet</ulink>
      attributes. They will be used later to generate the necessary
      persistence meta-data.</para>
    </section>

    <section>
      <title>Adding life-cycle behaviour</title>

      <para>What about the handling of the <code>Traceable</code> properties ?
      We want them to follow the life-cycle of any traceable entity, i.e.
      :</para>

      <itemizedlist>
        <listitem>
          <para>Set the <code>createTimestamp</code> when the entity is
          persisted for the first time.</para>
        </listitem>

        <listitem>
          <para>Set the <code>lastUpdateTimestamp</code> when the entity is
          updated in the persistent store.</para>
        </listitem>
      </itemizedlist>

      <para>It is time to write our first lines of java to achieve that. So
      let's create the life-cycle interceptor
      <code>com.d2s.framework.hrsample.model.service.TraceableLifecycleInterceptor</code>
      java class as follow :</para>

      <programlisting language="java">package com.d2s.framework.hrsample.model.service;

import java.util.Date;

import com.d2s.framework.hrsample.model.Traceable;
import com.d2s.framework.model.component.service.EmptyLifecycleInterceptor;
import com.d2s.framework.model.entity.IEntityFactory;
import com.d2s.framework.model.entity.IEntityLifecycleHandler;
import com.d2s.framework.security.UserPrincipal;

/**
 * Default lifecycle service for tracing.
 */
public class TraceableLifecycleInterceptor extends
    EmptyLifecycleInterceptor&lt;Traceable&gt; <co id="lcInterceptor" /> {

  /**
   * Sets the create timestamp.
   * &lt;p&gt;
   * {@inheritDoc}
   */
  @Override
  @SuppressWarnings("unused")
  public boolean onPersist(Traceable traceable, IEntityFactory entityFactory,
      UserPrincipal principal, IEntityLifecycleHandler entityLifecycleHandler) {
    traceable.setCreateTimestamp(new Date()); <co id="onPersist" />
    return true; <co id="onPersistReturn" />
  }

  /**
   * Sets the last update timestamp.
   * &lt;p&gt;
   * {@inheritDoc}
   */
  @Override
  @SuppressWarnings("unused")
  public boolean onUpdate(Traceable traceable, IEntityFactory entityFactory,
      UserPrincipal principal, IEntityLifecycleHandler entityLifecycleHandler) {
    traceable.setLastUpdateTimestamp(new Date()); <co id="onUpdate" />
    return true;
  }
}</programlisting>

      <calloutlist>
        <callout arearefs="lcInterceptor">
          <para>The class inherits from the support class
          <code>com.d2s.framework.model.component.service.EmptyLifecycleInterceptor</code>
          which empty implements the required life-cycle interceptor interface
          <code>com.d2s.framework.model.component.service.EmptyLifecycleInterceptor</code>
          as well as the marker interface
          <code>com.d2s.framework.model.component.service.IComponentService</code>.</para>
        </callout>

        <callout arearefs="onPersist">
          <para>Whenever a <code>Traceable</code> component is persisted
          (saved for the first time), set its
          <code>createTimestamp</code>.</para>
        </callout>

        <callout arearefs="onPersistReturn">
          <para>Return true to notify the framework that the state of the
          component has been updated.</para>
        </callout>

        <callout arearefs="onUpdate">
          <para>Whenever a <code>Traceable</code> component is updated
          (subsequent saves), update its
          <code>lastUpdateTimestamp</code>.</para>
        </callout>
      </calloutlist>

      <para>We can now link the life-cycle interceptor to our
      <code>Traceable</code> interface bean descriptor as below :</para>

      <para><programlisting language="xml">&lt;bean
  id="Traceable"
  class="com.d2s.framework.model.descriptor.basic.BasicInterfaceDescriptor"&gt;
  ...
  &lt;property name="lifecycleInterceptors"&gt; <co id="lcInterceptors" />
    &lt;list&gt;
      &lt;bean
        class="com.d2s.framework.hrsample.model.service.TraceableLifecycleInterceptor" /&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting><calloutlist>
          <callout arearefs="lcInterceptors">
            <para>Defines an ordered list of life-cycle interceptors attached
            to the component.</para>
          </callout>
        </calloutlist></para>
    </section>

    <section>
      <title>Entities</title>

      <para>As of now, we have only dealt with interfaces which are not
      entities by themselves. Describing an entity follows the exact same
      process except that we make its descriptor an entity descriptor.</para>

      <para>So let's describe the <code>City</code> entity as below :</para>

      <programlisting language="xml">&lt;bean
  id="City"
  class="com.d2s.framework.model.descriptor.entity.basic.BasicEntityDescriptor"&gt; <co
          id="BasicEntityDescriptor" />
  &lt;constructor-arg value="com.d2s.framework.hrsample.model.City" /&gt;
  &lt;property name="ancestorDescriptors"&gt; <co id="ancestorDescriptors" />
    &lt;list&gt;
      &lt;ref local="Nameable" /&gt;
    &lt;/list&gt;
  &lt;/property&gt;
  &lt;property name="propertyDescriptors"&gt;
    &lt;list&gt;
      &lt;bean
        class="com.d2s.framework.model.descriptor.basic.BasicStringPropertyDescriptor"&gt;
        &lt;property
          name="name"
          value="zip" /&gt;
        &lt;property
          name="maxLength"
          value="10" /&gt;
      &lt;/bean&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting>

      <calloutlist>
        <callout arearefs="BasicEntityDescriptor">
          <para>Since <code>City</code> is an entity, we use a
          <code>BasicEntityDescriptor</code> which is a special kind of
          component descriptor.</para>
        </callout>

        <callout arearefs="ancestorDescriptors">
          <para>This descriptor inherits from our <code>Nameable</code>
          interface as well as the standard
          <code>com.d2s.framework.model.entity.IEntity</code> descriptor
          bean.</para>
        </callout>
      </calloutlist>

      <para>Relaunching the <trademark>D2S</trademark> generator will produce
      the following class (<filename>City.java</filename>) :</para>

      <programlisting language="java">package com.d2s.framework.hrsample.model;

/**
 * City entity.
 * &lt;p&gt;
 * Generated by Design2see. All rights reserved.
 * &lt;p&gt;
 *
 * @hibernate.mapping
 *           default-access = "com.d2s.framework.model.persistence.hibernate.property.EntityPropertyAccessor"
 * @hibernate.class
 *   table = "CITY"
 *   dynamic-insert = "true"
 *   dynamic-update = "true"
 *   persister = "com.d2s.framework.model.persistence.hibernate.entity.persister.EntityProxyJoinedSubclassEntityPersister"
 * @author Generated by Design2see
 * @version $LastChangedRevision$
 */
public interface City extends
  com.d2s.framework.hrsample.model.Nameable,
  com.d2s.framework.model.entity.IEntity <co id="IEntity" /> {

  /**
   * @hibernate.id generator-class = "assigned" column = "ID" type = "string"
   *               length = "36"
   * &lt;p&gt;
   * {@inheritDoc}
   */
  java.io.Serializable getId();

  /**
   * @hibernate.version column = "VERSION" unsaved-value = "null"
   * &lt;p&gt;
   * {@inheritDoc}
   */
  Integer getVersion();

  /**
   * Gets the zip.
   *
   * @hibernate.property
   * @hibernate.column
   *           name = "ZIP"
   *           length = "10"
   * @return the zip.
   */
  java.lang.String getZip();

  /**
   * Sets the zip.
   *
   * @param zip
   *          the zip to set.
   */
  void setZip(java.lang.String zip);

}</programlisting>

      <calloutlist>
        <callout arearefs="IEntity">
          <para><code>City</code> is an entity so the generator made it
          inherit from <code>com.d2s.framework.model.entity.IEntity</code>
          which is a <trademark>D2S</trademark> framework base class.</para>
        </callout>
      </calloutlist>

      <para>You might notice that there are slightly more hibernate xDoclet
      tags (class level tags, id and version) to handle the entity persistence
      specifics. More important is that as for <code>Nameable</code> and
      <code>Traceable</code>, the <code>City</code> entity is not more than an
      interface. This brings to it a fundamental property which is
      multiple-inheritance; and this characteristic is also available among
      entities.</para>
    </section>

    <section>
      <title>Components</title>

      <para>A component is a data structure which is intended to be inlined in
      other components or entities. Like entities and interfaces, you can
      define properties and behaviour in a component. A component cannot live
      by itself. It is an elegant mean to factor common data and behaviour
      into higher level model parts.</para>

      <para>So let's describe the <code>ContactInfo</code> component as below
      :</para>

      <programlisting language="xml">&lt;bean
  id="ContactInfo"
  class="com.d2s.framework.model.descriptor.basic.BasicComponentDescriptor"&gt; <co
          id="BasicComponentDescriptor" />
  &lt;constructor-arg value="com.d2s.framework.hrsample.model.ContactInfo" /&gt;
  &lt;property name="propertyDescriptors"&gt;
    &lt;list&gt;
      &lt;bean
        class="com.d2s.framework.model.descriptor.basic.BasicStringPropertyDescriptor"&gt;
        &lt;property
          name="name"
          value="address" /&gt;
        &lt;property
          name="maxLength"
          value="256" /&gt;
      &lt;/bean&gt;
      &lt;bean
        class="com.d2s.framework.model.descriptor.basic.BasicStringPropertyDescriptor"&gt;
        &lt;property
          name="name"
          value="phone" /&gt;
        &lt;property
          name="maxLength"
          value="32" /&gt;
      &lt;/bean&gt;
      &lt;bean
        class="com.d2s.framework.model.descriptor.basic.BasicStringPropertyDescriptor"&gt;
        &lt;property
          name="name"
          value="email" /&gt;
        &lt;property
          name="maxLength"
          value="128" /&gt;
        &lt;property
          name="regexpPattern" <co id="regexpPattern" />
          value="[\w\-\.]*@[\w\-\.]*" /&gt;
        &lt;property
          name="regexpPatternSample" <co id="regexpPatternSample" />
          value="contact@acme.com" /&gt;
      &lt;/bean&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting>

      <calloutlist>
        <callout arearefs="BasicComponentDescriptor">
          <para>Since <code>ContactInfo</code> is an component, we use a
          <code>BasicComponentDescriptor</code>.</para>
        </callout>

        <callout arearefs="regexpPattern">
          <para>This is a special kind of string constraint enforcement
          through a regular expression; we want an email to conform to contain
          the @ sign, be without space and be only composed of literals plus
          '.' and '-'.</para>
        </callout>

        <callout arearefs="regexpPatternSample">
          <para>Whenever there is some kind of communication to initiate (a
          GUI notification for instance), this is an example of a correct
          value.</para>
        </callout>
      </calloutlist>

      <para>Relaunching the <trademark>D2S</trademark> generator will produce
      the following class (<filename>ContactInfo.java</filename>) :</para>

      <programlisting language="java">package com.d2s.framework.hrsample.model;

/**
 * ContactInfo component.
 * &lt;p&gt;
 * Generated by Design2see. All rights reserved.
 * &lt;p&gt;
 *
 * @author Generated by Design2see
 * @version $LastChangedRevision$
 */
public interface ContactInfo extends
  com.d2s.framework.model.component.IComponent <co id="IComponent" /> {

  /**
   * Gets the address.
   *
   * @hibernate.property
   * @hibernate.column
   *           name = "ADDRESS"
   *           length = "256"
   * @return the address.
   */
  java.lang.String getAddress();

  /**
   * Sets the address.
   *
   * @param address
   *          the address to set.
   */
  void setAddress(java.lang.String address);

  /**
   * Gets the phone.
   *
   * @hibernate.property
   * @hibernate.column
   *           name = "PHONE"
   *           length = "32"
   * @return the phone.
   */
  java.lang.String getPhone();

  /**
   * Sets the phone.
   *
   * @param phone
   *          the phone to set.
   */
  void setPhone(java.lang.String phone);

  /**
   * Gets the email.
   *
   * @hibernate.property
   * @hibernate.column
   *           name = "EMAIL"
   *           length = "128"
   * @return the email.
   */
  java.lang.String getEmail();

  /**
   * Sets the email.
   *
   * @param email
   *          the email to set.
   */
  void setEmail(java.lang.String email);

}</programlisting>

      <calloutlist>
        <callout arearefs="IComponent">
          <para><code>ContactInfo</code> is an entity so the generator made it
          inherit from
          <code>com.d2s.framework.model.component.IComponent</code> which is a
          <trademark>D2S</trademark> framework base class.</para>
        </callout>
      </calloutlist>

      <para>You might have notice that the <code>ContactInfo</code> component
      is missing something : its relationship to the <code>City</code>
      entity.</para>
    </section>

    <section>
      <title>Unidirectional relationships</title>

      <para>It's time to link our first components together.</para>

      <section>
        <title>Unidirectional N-1 relationships</title>

        <para>Let's first deal with the simple unidirectional association
        <code>ContactInfo</code> â†’ <code>City</code>. We are going to define a
        <code>city</code> property in the <code>ContactInfo</code>
        component.</para>

        <para>The following XML fragment will do the trick :</para>

        <programlisting language="xml">&lt;bean
  id="ContactInfo"
  class="com.d2s.framework.model.descriptor.basic.BasicComponentDescriptor"&gt;
  &lt;constructor-arg value="com.d2s.framework.hrsample.model.ContactInfo" /&gt;
  &lt;property name="propertyDescriptors"&gt;
    &lt;list&gt;
      ...
      &lt;bean
        class="com.d2s.framework.model.descriptor.basic.BasicReferencePropertyDescriptor"&gt; <co
            id="BasicReferencePropertyDescriptor" />
        &lt;property
          name="name"
          value="city" /&gt;
        &lt;property
          name="referencedDescriptor"
          ref="City" /&gt; <co id="referencedDescriptor" />
      &lt;/bean&gt;
      ...
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting>

        <para><calloutlist>
            <callout arearefs="BasicReferencePropertyDescriptor">
              <para><code>ContactInfo</code> has a reference to the
              <code>City</code> entity so we describe this using a
              <code>com.d2s.framework.model.descriptor.basic.BasicReferencePropertyDescriptor</code>.</para>
            </callout>

            <callout arearefs="referencedDescriptor">
              <para>We link the reference property descriptor to the
              <code>City</code> entity descriptor we described above (note the
              usage of the <emphasis role="bold">ref</emphasis> spring
              attribute).</para>
            </callout>
          </calloutlist>Relaunching the <trademark>D2S</trademark> generator
        will update the <filename>ContactInfo.java</filename> source file we
        generated above, but since this is a unidirectional relationship, the
        <filename>City.java</filename> file will remain untouched. The
        following lines are added in the <filename>ContactInfo.java</filename>
        source file :</para>

        <para><programlisting language="java">  /**
   * Gets the city.
   *
   * @hibernate.many-to-one
   *           cascade = "persist,merge,save-update,refresh,evict,replicate"
   * @hibernate.column
   *           name = "CITY_ID"
   * @return the city.
   */
  com.d2s.framework.hrsample.model.City getCity();

  /**
   * Sets the city.
   *
   * @param city
   *          the city to set.
   */
  void setCity(com.d2s.framework.hrsample.model.City city);</programlisting>Again,
        the needed hibernate xDoclet tags are added to reflect the
        relationship between the component and the entity.</para>

        <para>To end with the commons model part, let's define the Event
        entity :</para>

        <para><programlisting language="xml">&lt;bean
  id="Event"
  class="com.d2s.framework.model.descriptor.entity.basic.BasicEntityDescriptor"&gt;
  &lt;constructor-arg value="com.d2s.framework.hrsample.model.Event" /&gt;
  &lt;property name="ancestorDescriptors"&gt;
    &lt;list&gt;
      &lt;ref local="Traceable" /&gt; <co id="Traceable" />
    &lt;/list&gt;
  &lt;/property&gt;
  &lt;property name="propertyDescriptors"&gt;
    &lt;list&gt;
      &lt;bean
        class="com.d2s.framework.model.descriptor.basic.BasicTextPropertyDescriptor"&gt; <co
              id="BasicTextPropertyDescriptor" />
        &lt;property
          name="name"
          value="text" /&gt;
        &lt;property
          name="maxLength"
          value="2048" /&gt;
      &lt;/bean&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting><calloutlist>
            <callout arearefs="Traceable">
              <para>An event is a <code>Traceable</code> entity.</para>
            </callout>

            <callout arearefs="BasicTextPropertyDescriptor">
              <para>We use a
              <code>com.d2s.framework.model.descriptor.basic.BasicTextPropertyDescriptor</code>
              instead of a
              <code>com.d2s.framework.model.descriptor.basic.BasicStringPropertyDescriptor</code>.
              This is to inform the framework the this property is likely to
              receive multi-line text; although there is no direct impact on
              the model layer, it might be useful in the view layer (e.g. :
              use a text area instead of a text field to display and edit the
              <code>Event</code> text property).</para>
            </callout>
          </calloutlist>This first relationship is fairly simple since it is a
        n-1 unidirectional association. Of course, the
        <trademark>D2S</trademark> can seamlessly handle 1-n, 1-1 and n-n
        unidirectional and bi-directional associations and compositions
        (strong aggregations).</para>

        <para>Now that we are done with the commons model part, let's see how
        we can handle the employees model part.</para>
      </section>

      <section>
        <title>Inlined components</title>

        <para>The <code>Employee</code> entity is fairly simple to describe
        giving what we already achieved.</para>

        <para>Let's look at the XML fragment below :</para>

        <para><programlisting language="xml">&lt;bean
  id="Employee"
  class="com.d2s.framework.model.descriptor.entity.basic.BasicEntityDescriptor"&gt;
  &lt;constructor-arg value="com.d2s.framework.hrsample.model.Employee" /&gt;
  &lt;property name="ancestorDescriptors"&gt;
    &lt;list&gt;
      &lt;ref local="Nameable" /&gt;
      &lt;ref local="Traceable" /&gt;
    &lt;/list&gt;
  &lt;/property&gt;
  &lt;property name="propertyDescriptors"&gt;
    &lt;list&gt;
      &lt;bean
        class="com.d2s.framework.model.descriptor.basic.BasicStringPropertyDescriptor"&gt;
        &lt;property
          name="name"
          value="firstName" /&gt;
        &lt;property
          name="maxLength"
          value="32" /&gt;
      &lt;/bean&gt;
      &lt;bean
        class="com.d2s.framework.model.descriptor.basic.BasicStringPropertyDescriptor"&gt;
        &lt;property
          name="name"
          value="ssn" /&gt;
        &lt;property
          name="maxLength"
          value="10" /&gt;
        &lt;property
          name="regexpPattern"
          value="[\d]{10}" /&gt; <co id="ssn" />
        &lt;property
          name="regexpPatternSample"
          value="0123456789" /&gt;
        &lt;property
          name="unicityScope"
          value="empSsn" /&gt; <co id="unicityScope" />
      &lt;/bean&gt;
      &lt;bean
        class="com.d2s.framework.model.descriptor.basic.BasicDatePropertyDescriptor"&gt;
        &lt;property
          name="name"
          value="birthDate" /&gt;
        &lt;property
          name="type"
          ref="DATE" /&gt; <co id="birthDate" />
      &lt;/bean&gt;
      &lt;bean
        class="com.d2s.framework.model.descriptor.basic.BasicDatePropertyDescriptor"&gt;
        &lt;property
          name="name"
          value="hireDate" /&gt;
        &lt;property
          name="type"
          ref="DATE" /&gt;
      &lt;/bean&gt;
      &lt;bean
        class="com.d2s.framework.model.descriptor.basic.BasicEnumerationPropertyDescriptor"&gt; <co
              id="BasicEnumerationPropertyDescriptor" />
        &lt;property
          name="name"
          value="gender" /&gt;
        &lt;property
          name="enumerationName"
          value="GENDER" /&gt;
        &lt;property
          name="maxLength"
          value="1" /&gt;
        &lt;property
          name="mandatory"
          value="true" /&gt;
        &lt;property name="valuesAndIconImageUrls"&gt; <co
              id="valuesAndIconImageUrls" />
          &lt;map&gt;
            &lt;entry
              key="M"
              value="classpath:com/d2s/framework/hrsample/images/male-48x48.png" /&gt;
            &lt;entry
              key="F"
              value="classpath:com/d2s/framework/hrsample/images/female-48x48.png" /&gt;
          &lt;/map&gt;
        &lt;/property&gt;
      &lt;/bean&gt;
      &lt;bean
        class="com.d2s.framework.model.descriptor.basic.BasicReferencePropertyDescriptor"&gt; <co
              id="inlinedComp" />
        &lt;property
          name="name"
          value="contact" /&gt;
        &lt;property
          name="referencedDescriptor"
          ref="ContactInfo" /&gt;
      &lt;/bean&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting><calloutlist>
            <callout arearefs="ssn">
              <para>We defined a regular expression control on the ssn
              property since it must be composed of 10 and only 10
              digits.</para>
            </callout>

            <callout arearefs="birthDate">
              <para>We don't care about the time information of this date; so
              we use a DATE type as opposed to the DATE_TIME type that we used
              for the <code>Traceable</code> interface.</para>
            </callout>

            <callout arearefs="BasicEnumerationPropertyDescriptor">
              <para>This is a new kind of property descriptor. This one
              defines a finite choice of values for the property.</para>
            </callout>

            <callout arearefs="valuesAndIconImageUrls">
              <para>We define each of the values composing the choice for the
              gender enumeration (either 'M' or 'F') along with icons if
              available.</para>
            </callout>

            <callout arearefs="inlinedComp">
              <para>This is where we reference the <code>ContactInfo</code>
              component.</para>
            </callout>
          </calloutlist>The employee description above shows that it is
        strictly equivalent - as far as description is concerned - to
        reference an entity or to inline a component (see the contact
        reference). The difference will be in the persistence store and in the
        views since an inlined component will have its attributes "merged"
        with the enclosing component as if they belonged to it.</para>
      </section>

      <section>
        <title>Unidirectional 1-N relationships</title>

        <para>You have surely noticed that we did not describe the 1-N
        composition between <code>Employee</code> and <code>Event</code>. This
        will be our first collection property and since this description will
        be re-used in views (to view and edit the events of an employee), we
        will put it in its own &lt;bean&gt; section so that we can assign it a
        spring id and reference it later :</para>

        <para><programlisting language="xml">&lt;bean
  id="Employee-events"
  class="com.d2s.framework.model.descriptor.basic.BasicCollectionPropertyDescriptor"&gt; <co
              id="BasicCollectionPropertyDescriptor" />
  &lt;property
    name="name"
    value="events" /&gt;
  &lt;property
    name="composition"
    value="true" /&gt; <co id="composition" />
  &lt;property name="referencedDescriptor"&gt;
    &lt;bean
      class="com.d2s.framework.model.descriptor.basic.BasicCollectionDescriptor"&gt; <co
              id="BasicCollectionDescriptor" />
      &lt;property
        name="collectionInterface"
        value="java.util.List" /&gt; <co id="collectionInterface" />
      &lt;property
        name="elementDescriptor"
        ref="Event" /&gt; <co id="elementDescriptor" />
    &lt;/bean&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting><calloutlist>
            <callout arearefs="BasicCollectionPropertyDescriptor">
              <para>We are describing a collection relationship property. This
              is done using a
              <code>com.d2s.framework.model.descriptor.basic.BasicCollectionPropertyDescriptor</code>.</para>
            </callout>

            <callout arearefs="unicityScope">
              <para>We define a unicity domain for the <code>ssn</code>
              property. This will translate in a unique key definition in the
              persistent store.</para>
            </callout>

            <callout arearefs="composition">
              <para>We make this relationship a composition to express the
              fact that whenever an employee is deleted, the attached events
              must also be deleted.</para>
            </callout>

            <callout arearefs="BasicCollectionDescriptor">
              <para>A collection property descriptor always references a
              collection descriptor (which may be reused across different
              collection property descriptors)</para>
            </callout>

            <callout arearefs="collectionInterface">
              <para>We need an ordered list of event as specified in the
              analysis; so we use a <code>java.util.List</code> to achieve
              that. We could have used <code>java.util.Set</code> for a set
              semantic (no duplicate and unordered).</para>
            </callout>

            <callout arearefs="elementDescriptor">
              <para>Our collection property lists events; so we reference the
              <code>Event</code> descriptor as being the element type of our
              collection.</para>
            </callout>
          </calloutlist>Then we need to reference the
        <code>Employee-events</code> collection property descriptor in the
        Employee entity. This is done in a single line as shown below :</para>

        <para><programlisting language="xml">&lt;bean
  id="Employee"
  class="com.d2s.framework.model.descriptor.entity.basic.BasicEntityDescriptor"&gt;
  &lt;constructor-arg value="com.d2s.framework.hrsample.model.Employee" /&gt;
  ...
  &lt;property name="propertyDescriptors"&gt;
    &lt;list&gt;
      ...
      &lt;ref local="Employee-events" /&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting></para>

        <para>As a general rule, you have to remember that each and every bean
        definition in spring can be factored and re-used by making it a
        top-level bean and assigning it an id. This is what we have done for
        the <code>Employee-events</code> descriptor (for later reference but
        not for re-use). All the power of the Spring dependency injection
        container comes into play. For instance, we could easily decide to
        define short (32), medium (128) and long (512) parent string
        descriptors and have all our application string descriptors inherit
        from these. It would make the model more homogeneous and any change a
        matter of an instant. Following this principles, we encourage you to
        make re-usable descriptor bean libraries you can reference among your
        applications. Your descriptor sources will be more concise and more
        readable and maintainable.</para>

        <para>Launching the <trademark>D2S</trademark> generator will generate
        the <filename>Employee.java</filename> source file :</para>

        <para><programlisting language="java">package com.d2s.framework.hrsample.model;

/**
 * Employee entity.
 * &lt;p&gt;
 * Generated by Design2see. All rights reserved.
 * &lt;p&gt;
 * 
 * @hibernate.mapping default-access =
 *                    "com.d2s.framework.model.persistence.hibernate.property.EntityPropertyAccessor"
 * @hibernate.class table = "EMPLOYEE"
 *   dynamic-insert = "true"
 *   dynamic-update = "true" persister =
 *   "com.d2s.framework.model.persistence.hibernate.entity.persister.EntityProxyJoinedSubclassEntityPersister"
 * @author Generated by Design2see
 * @version $LastChangedRevision$
 */
public interface Employee extends com.d2s.framework.hrsample.model.Nameable,
    com.d2s.framework.hrsample.model.Traceable,
    com.d2s.framework.model.entity.IEntity {

  /**
   * @hibernate.id generator-class = "assigned" column = "ID" type = "string"
   *               length = "36"
   *               &lt;p&gt;
   *               {@inheritDoc}
   */
  java.io.Serializable getId();

  /**
   * @hibernate.version column = "VERSION" unsaved-value = "null"
   *                    &lt;p&gt;
   *                    {@inheritDoc}
   */
  Integer getVersion();

  /**
   * Gets the firstName.
   * 
   * @hibernate.property
   * @hibernate.column name = "FIRST_NAME" length = "32"
   * @return the firstName.
   */
  java.lang.String getFirstName();

  /**
   * Sets the firstName.
   * 
   * @param firstName
   *            the firstName to set.
   */
  void setFirstName(java.lang.String firstName);

  /**
   * Gets the ssn.
   * 
   * @hibernate.property
   * @hibernate.column name = "SSN" length = "10" unique-key = "EMP_SSN_UNQ"
   * @return the ssn.
   */
  java.lang.String getSsn();

  /**
   * Sets the ssn.
   * 
   * @param ssn
   *            the ssn to set.
   */
  void setSsn(java.lang.String ssn);

  /**
   * Gets the birthDate.
   * 
   * @hibernate.property type = "date"
   * @hibernate.column name = "BIRTH_DATE"
   * @return the birthDate.
   */
  java.util.Date getBirthDate();

  /**
   * Sets the birthDate.
   * 
   * @param birthDate
   *            the birthDate to set.
   */
  void setBirthDate(java.util.Date birthDate);

  /**
   * Gets the hireDate.
   * 
   * @hibernate.property type = "date"
   * @hibernate.column name = "HIRE_DATE"
   * @return the hireDate.
   */
  java.util.Date getHireDate();

  /**
   * Sets the hireDate.
   * 
   * @param hireDate
   *            the hireDate to set.
   */
  void setHireDate(java.util.Date hireDate);

  /**
   * Gets the gender.
   * 
   * @hibernate.property
   * @hibernate.column name = "GENDER" length = "1" not-null = "true"
   * @return the gender.
   */
  java.lang.String getGender();

  /**
   * Sets the gender.
   * 
   * @param gender
   *            the gender to set.
   */
  void setGender(java.lang.String gender);

  /**
   * Gets the contact.
   * 
   * @hibernate.component prefix = "CONTACT_"
   * @return the contact.
   */
  com.d2s.framework.hrsample.model.ContactInfo getContact();

  /**
   * Sets the contact.
   * 
   * @param contact
   *            the contact to set.
   */
  void setContact(com.d2s.framework.hrsample.model.ContactInfo contact);

  /**
   * Gets the events.
   * 
   * @hibernate.list cascade =
   *                 "persist,merge,save-update,refresh,evict,replicate,delete"
   * @hibernate.key column = "EVENTS_PARENT_ID"
   * @hibernate.one-to-many class = "com.d2s.framework.hrsample.model.Event"
   * @hibernate.list-index column = "EVENTS_SEQ"
   * @return the events.
   */
  java.util.List&lt;com.d2s.framework.hrsample.model.Event&gt; getEvents();

  /**
   * Sets the events.
   * 
   * @param events
   *            the events to set.
   */
  void setEvents(java.util.List&lt;com.d2s.framework.hrsample.model.Event&gt; events);

  /**
   * Adds an element to the events.
   * 
   * @param eventsElement
   *            the events element to add.
   */
  void addToEvents(com.d2s.framework.hrsample.model.Event eventsElement);

  /**
   * Adds an element to the events at the specified index. If the index is out
   * of the list bounds, the element is simply added at the end of the list.
   * 
   * @param index
   *            the index to add the events element at.
   * @param eventsElement
   *            the events element to add.
   */
  void addToEvents(int index,
      com.d2s.framework.hrsample.model.Event eventsElement);

  /**
   * Removes an element from the events.
   * 
   * @param eventsElement
   *            the events element to remove.
   */
  void removeFromEvents(com.d2s.framework.hrsample.model.Event eventsElement);

}</programlisting>As you can see above, the generator has generated all the
        accessors for the events list property. If the events property had
        been designed as a set instead of a list, the adder using the index
        would not have been generated and the get/set pair would of course
        have used a <code>java.util.Set</code> instead of a
        <code>java.util.List</code>.</para>

        <para>Now that the employees model part is complete, let's deal with
        the organization.</para>
      </section>
    </section>

    <section>
      <title>Entity inheritance</title>

      <para>The organization model part is the most complex of the example,
      since it involves entity inheritance (and polymorphism) and other kinds
      of relationships (1-1, bi-directional). So let's begin with the entity
      inheritance graph and we will deal with their relationships next.</para>

      <para><programlisting language="xml">&lt;bean
  id="Company"
  class="com.d2s.framework.model.descriptor.entity.basic.BasicEntityDescriptor"&gt;
  &lt;constructor-arg value="com.d2s.framework.hrsample.model.Company" /&gt;
  &lt;property name="ancestorDescriptors"&gt;
    &lt;list&gt;
      &lt;ref local="Nameable" /&gt;
      &lt;ref local="Traceable" /&gt;
    &lt;/list&gt;
  &lt;/property&gt;
  &lt;property name="propertyDescriptors"&gt;
    &lt;list&gt;
      &lt;bean
        class="com.d2s.framework.model.descriptor.basic.BasicReferencePropertyDescriptor"&gt;
        &lt;property
          name="name"
          value="contact" /&gt;
        &lt;property
          name="referencedDescriptor"
          ref="ContactInfo" /&gt;
      &lt;/bean&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;

&lt;bean
  id="OrganizationalUnit"
  class="com.d2s.framework.model.descriptor.entity.basic.BasicEntityDescriptor"&gt;
  &lt;constructor-arg value="com.d2s.framework.hrsample.model.OrganizationalUnit" /&gt;
  &lt;property name="purelyAbstract" value="true" /&gt; <co
            id="purelyAbstract" />
  &lt;property name="ancestorDescriptors"&gt;
    &lt;list&gt;
      &lt;ref local="Nameable" /&gt;
      &lt;ref local="Traceable" /&gt;
    &lt;/list&gt;
  &lt;/property&gt;
  &lt;property name="propertyDescriptors"&gt;
    &lt;list&gt;
      &lt;bean
        class="com.d2s.framework.model.descriptor.basic.BasicStringPropertyDescriptor"&gt;
        &lt;property
          name="name"
          value="ouId" /&gt;
        &lt;property
          name="regexpPattern"
          value="[A-Z]{2}-[\d]{3}" /&gt;
        &lt;property
          name="regexpPatternSample"
          value="IS-123" /&gt;
        &lt;property
          name="maxLength"
          value="6" /&gt;
        &lt;property
          name="mandatory"
          value="true" /&gt;
      &lt;/bean&gt;
      &lt;bean
        class="com.d2s.framework.model.descriptor.basic.BasicReferencePropertyDescriptor"&gt;
        &lt;property
          name="name"
          value="contact" /&gt;
        &lt;property
          name="referencedDescriptor"
          ref="ContactInfo" /&gt;
      &lt;/bean&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;

&lt;bean
  id="Department"
  class="com.d2s.framework.model.descriptor.entity.basic.BasicEntityDescriptor"&gt;
  &lt;constructor-arg value="com.d2s.framework.hrsample.model.Department" /&gt;
  &lt;property name="ancestorDescriptors"&gt;
    &lt;list&gt;
      &lt;ref local="OrganizationalUnit" /&gt; <co id="OrganizationalUnit" />
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;

&lt;bean
  id="Team"
  class="com.d2s.framework.model.descriptor.entity.basic.BasicEntityDescriptor"&gt;
  &lt;constructor-arg value="com.d2s.framework.hrsample.model.Team" /&gt;
  &lt;property name="ancestorDescriptors"&gt;
    &lt;list&gt;
      &lt;ref local="OrganizationalUnit" /&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting><calloutlist>
          <callout arearefs="purelyAbstract">
            <para>An <code>OrganizationalUnit</code> will never be
            instantiated as such; only sub-entities will. This is why we
            define the entity as purely abstract.</para>
          </callout>

          <callout arearefs="OrganizationalUnit">
            <para><code>Department</code> inherits from
            <code>OrganizationalUnit</code> as do <code>Team</code>.</para>
          </callout>
        </calloutlist>Pretty easy, no ? You describe entity inheritance
      exactly as you did previously for the interfaces. You don't have to care
      for anything else, the framework will handle it behind the scene for
      you.</para>

      <para>You can see also that <code>Company</code>,
      <code>OrganizationalUnit</code>, and <code>Employee</code> have the same
      contact property as an inlined <code>ContactInfo</code> component. It is
      a perfect candidate for factoring. So we can make the contact property
      descriptor a top level bean and reference it in the 3 entities above.
      The result will be :</para>

      <para><programlisting language="xml">&lt;bean id="contact"
  class="com.d2s.framework.model.descriptor.basic.BasicReferencePropertyDescriptor"&gt; <co
            id="contact" />
  &lt;property
    name="name"
    value="contact" /&gt;
  &lt;property
    name="referencedDescriptor"
    ref="ContactInfo" /&gt;
&lt;/bean&gt;
...
&lt;bean
  id="Employee"
  class="com.d2s.framework.model.descriptor.entity.basic.BasicEntityDescriptor"&gt;
  ...
  &lt;property name="propertyDescriptors"&gt;
    &lt;list&gt;
      ...
      &lt;ref bean="contact" /&gt; <co id="contactrefEmployee" />
      ...
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;
...
&lt;bean
  id="Company"
  class="com.d2s.framework.model.descriptor.entity.basic.BasicEntityDescriptor"&gt;
  ...
  &lt;property name="propertyDescriptors"&gt;
    &lt;list&gt;
      &lt;ref bean="contact" /&gt; <co id="contactrefCompany" />
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;
...
&lt;bean
  id="OrganizationalUnit"
  class="com.d2s.framework.model.descriptor.entity.basic.BasicEntityDescriptor"&gt;
  ...
  &lt;property name="propertyDescriptors"&gt;
    &lt;list&gt;
      ...
      &lt;ref bean="contact" /&gt; <co id="contactrefOU" />
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting><calloutlist>
          <callout arearefs="contact">
            <para>We factor the contact property in a top level referenceable
            bean.</para>
          </callout>

          <callout arearefs="contactrefEmployee">
            <para>We reference the contact bean as a property of the
            <code>Employee</code> entity.</para>
          </callout>

          <callout arearefs="contactrefCompany">
            <para>We reference the contact bean as a property of the
            <code>Company</code> entity.</para>
          </callout>

          <callout arearefs="contactrefOU">
            <para>We reference the contact bean as a property of the
            <code>OrganizationalUnit</code> entity.</para>
          </callout>
        </calloutlist>Now that we have described our organization entities,
      let's link them together using relationships.</para>
    </section>

    <section>
      <title>Bi-directional relationships</title>

      <para>It is time see how the <trademark>D2S</trademark> framework
      handles relationships which are navigable at both ends.</para>

      <section>
        <title>Bi-directional 1-N relationships</title>

        <para>We are going to describe the <code>Company</code> &lt;-&gt;
        <code>Department</code> bi-directional 1-N relationship. To achieve
        that, we will first describe the N side of this composition, making it
        a top-level, referenceable bean and then make this N side the reverse
        end of the 1 side of the composition. This is achieved using the
        following XML fragment :</para>

        <para><programlisting language="xml">&lt;bean
  id="Company-departments"
  class="com.d2s.framework.model.descriptor.basic.BasicCollectionPropertyDescriptor"&gt; <co
              id="Company-departments" />
  &lt;property
    name="name"
    value="departments" /&gt;
  &lt;property
    name="composition"
    value="true" /&gt;
  &lt;property name="referencedDescriptor"&gt;
    &lt;bean
      class="com.d2s.framework.model.descriptor.basic.BasicCollectionDescriptor"&gt;
      &lt;property
        name="collectionInterface"
        value="java.util.Set" /&gt;
      &lt;property
        name="elementDescriptor"
        ref="Department" /&gt;
    &lt;/bean&gt;
  &lt;/property&gt;
&lt;/bean&gt;
...
&lt;bean
  id="Company"
  class="com.d2s.framework.model.descriptor.entity.basic.BasicEntityDescriptor"&gt;
  ...
  &lt;property name="propertyDescriptors"&gt;
    &lt;list&gt;
      ...
      &lt;ref bean="Company-departments"/&gt; <co id="Company-departments-ref" />
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;
...
&lt;bean
  id="Department"
  class="com.d2s.framework.model.descriptor.entity.basic.BasicEntityDescriptor"&gt;
  ...
  &lt;property name="propertyDescriptors"&gt;
    &lt;list&gt;
      &lt;bean
        class="com.d2s.framework.model.descriptor.basic.BasicReferencePropertyDescriptor"&gt; <co
              id="company-ref" />
        &lt;property
          name="name"
          value="company" /&gt;
        &lt;property
          name="referencedDescriptor"
          ref="Company" /&gt;
        &lt;property
          name="reverseRelationEnd"
          ref="Company-departments" /&gt; <co id="reverseRelationEnd" />
        &lt;property
          name="mandatory"
          value="true" /&gt;
      &lt;/bean&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting></para>

        <para><calloutlist>
            <callout arearefs="Company-departments">
              <para>Like we did before for the employee events, we describe
              collection property descriptor for the company
              departments.</para>
            </callout>

            <callout arearefs="Company-departments-ref">
              <para>We reference the collection property descriptor in the
              <code>Company</code> entity.</para>
            </callout>

            <callout arearefs="company-ref">
              <para>We define a reference descriptor to the Company entity in
              the Department entity.</para>
            </callout>

            <callout arearefs="reverseRelationEnd">
              <para>We link both side of the <code>Company</code> &lt;-&gt;
              <code>Department</code> relationship.</para>
            </callout>
          </calloutlist>So making a relationship bi-directional is quite
        straightforward. We just have to reference one end of the relationship
        in the other end as being the reverse end. Although the generated java
        code will not be directly impacted by making a relationship
        bi-directional, hibernate xDoclet tags will be. More important is the
        impact on how the framework will handle the relationship updates
        behind the scene for you.</para>

        <para>Making the <code>Company</code> &lt;-&gt;
        <code>Department</code> relationship bi-directional implies the
        following on the <code>Company</code> side:</para>

        <para><orderedlist>
            <listitem>
              <para>Whenever a department is added to a company through the
              <code>addToDepartments(Department)</code> adder, the passed-in
              department will have its company property updated accordingly.
              In the (unexpected) case that the department was part of another
              company, it will be removed from its previous company
              departments before being added to the new one.</para>
            </listitem>

            <listitem>
              <para>Whenever a set of departments set as the company
              departments through the
              <code>setDepartments(Set&lt;Department&gt;)</code> setter, all
              the passed-in departments will have their company property
              updated accordingly. In the (unexpected) case that the
              departments were part of other companies, they will be removed
              from their previous respective company departments before being
              added to the new one. Moreover, all existing departments in the
              company before the update will have their company property
              reset.</para>
            </listitem>

            <listitem>
              <para>Whenever a department is removed from a company through
              the <code>removeFromDepartments(Department)</code> remover, the
              passed-in department will have its company property reset to
              <code>null</code>. In the (unexpected) case that the department
              was part of another company, it will be removed from its
              previous company departments.</para>
            </listitem>
          </orderedlist>And on the <code>Department</code> side :</para>

        <orderedlist>
          <listitem>
            <para>Whenever a company is set in a department through the
            <code>setCompany(Company)</code>, the company departments is
            updated accordingly. In the case that the passed-in company is
            <code>null</code>, the department will just be removed from its
            previous company if any.</para>
          </listitem>
        </orderedlist>

        <para>As you can see above, you can expect the
        <trademark>D2S</trademark> framework to extensively and transparently
        manage any bi-directional relationship for you. Just call whatever
        accessor you want and the domain model will be updated
        consistently.</para>

        <para>We describe the <code>Department</code> &lt;-&gt;
        <code>Team</code> relationship the same way :</para>

        <para><programlisting language="xml">&lt;bean
  id="Department-teams"
  class="com.d2s.framework.model.descriptor.basic.BasicCollectionPropertyDescriptor"&gt;
  &lt;property
    name="name"
    value="teams" /&gt;
  &lt;property
    name="composition"
    value="true" /&gt;
  &lt;property name="referencedDescriptor"&gt;
    &lt;bean
      class="com.d2s.framework.model.descriptor.basic.BasicCollectionDescriptor"&gt;
      &lt;property
        name="collectionInterface"
        value="java.util.Set" /&gt;
      &lt;property
        name="elementDescriptor"
        ref="Team" /&gt;
    &lt;/bean&gt;
  &lt;/property&gt;
&lt;/bean&gt;

&lt;bean
  id="Department"
  class="com.d2s.framework.model.descriptor.entity.basic.BasicEntityDescriptor"&gt;
  &lt;constructor-arg value="com.d2s.framework.hrsample.model.Department" /&gt;
  ...
  &lt;property name="propertyDescriptors"&gt;
    &lt;list&gt;
      ...
      &lt;ref bean="Department-teams" /&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;

&lt;bean
  id="Team"
  class="com.d2s.framework.model.descriptor.entity.basic.BasicEntityDescriptor"&gt;
  ...
  &lt;property name="propertyDescriptors"&gt;
    &lt;list&gt;
      &lt;bean
        class="com.d2s.framework.model.descriptor.basic.BasicReferencePropertyDescriptor"&gt;
        &lt;property
          name="name"
          value="department" /&gt;
        &lt;property
          name="referencedDescriptor"
          ref="Department" /&gt;
        &lt;property
          name="reverseRelationEnd"
          ref="Department-teams" /&gt;
        &lt;property
          name="mandatory"
          value="true" /&gt;
      &lt;/bean&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting>And, to be complete, the <code>Company</code>
        &lt;-&gt; <code>Employees</code> relationship :<programlisting
        language="xml">&lt;bean
  id="Company-employees"
  class="com.d2s.framework.model.descriptor.basic.BasicCollectionPropertyDescriptor"&gt;
  &lt;property
    name="name"
    value="employees" /&gt;
  &lt;property
    name="composition"
    value="true" /&gt;
  &lt;property name="referencedDescriptor"&gt;
    &lt;bean
      class="com.d2s.framework.model.descriptor.basic.BasicCollectionDescriptor"&gt;
      &lt;property
        name="collectionInterface"
        value="java.util.Set" /&gt;
      &lt;property
        name="elementDescriptor"
        ref="Employee" /&gt;
    &lt;/bean&gt;
  &lt;/property&gt;
&lt;/bean&gt;
...
&lt;bean
  id="Employee"
  class="com.d2s.framework.model.descriptor.entity.basic.BasicEntityDescriptor"&gt;
  ...
  &lt;property name="propertyDescriptors"&gt;
    &lt;list&gt;
      ...
      &lt;bean
        class="com.d2s.framework.model.descriptor.basic.BasicReferencePropertyDescriptor"&gt;
        &lt;property
          name="name"
          value="company" /&gt;
        &lt;property
          name="referencedDescriptor"
          ref="Company" /&gt;
        &lt;property
          name="reverseRelationEnd"
          ref="Company-employees" /&gt;
        &lt;property
          name="mandatory"
          value="true" /&gt;
      &lt;/bean&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;
...
&lt;bean
  id="Company"
  class="com.d2s.framework.model.descriptor.entity.basic.BasicEntityDescriptor"&gt;
  ...
  &lt;property name="propertyDescriptors"&gt;
    &lt;list&gt;
      ...
      &lt;ref bean="Company-employees" /&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting></para>
      </section>

      <section>
        <title>Bi-directional 1-1 relationships</title>

        <para>The last type of relationship we will handle in the HR
        application is the 1-1 <code>OrganizationalUnit</code> &lt;-&gt;
        <code>Employee</code> manager association. And you have certainly
        already guessed that it is the exact same way to describe
        bi-directional 1-1 relationships than 1-N relationships except that
        both ends are reference property descriptors :<programlisting
        language="xml">&lt;bean
  id="OrganizationalUnit-manager"
  class="com.d2s.framework.model.descriptor.basic.BasicReferencePropertyDescriptor"&gt;
  &lt;property
    name="name"
    value="manager" /&gt;
  &lt;property name="referencedDescriptor" ref="Employee"/&gt;
  &lt;property name="mandatory" value="true" /&gt;
&lt;/bean&gt;
...
&lt;bean
  id="Employee"
  class="com.d2s.framework.model.descriptor.entity.basic.BasicEntityDescriptor"&gt;
  ...
  &lt;property name="propertyDescriptors"&gt;
    &lt;list&gt;
      ...
      &lt;bean
        class="com.d2s.framework.model.descriptor.basic.BasicReferencePropertyDescriptor"&gt;
        &lt;property
          name="name"
          value="managedOu" /&gt;
        &lt;property
          name="referencedDescriptor"
          ref="OrganizationalUnit" /&gt;
        &lt;property
          name="reverseRelationEnd"
          ref="OrganizationalUnit-manager" /&gt;
      &lt;/bean&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;
...
&lt;bean
  id="OrganizationalUnit"
  class="com.d2s.framework.model.descriptor.entity.basic.BasicEntityDescriptor"&gt;
  ...
  &lt;property name="propertyDescriptors"&gt;
    &lt;list&gt;
      ...
      &lt;ref bean="OrganizationalUnit-manager"/&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting></para>

        <para>Of course, setting one end of the 1-1 relationship will also
        update the other end accordingly without having to take care of
        it.</para>
      </section>
    </section>

    <section>
      <title>Component services</title>

      <para>As of now, we have only dealt with <trademark>D2S</trademark>
      component properties. There might be situations where you want (or you
      need) your domain model components to implement arbitrary interfaces
      (maybe legacy interfaces) and provide an arbitrary implementation for
      them. The <trademark>D2S</trademark> framework supports it at any level
      of the domain model. As an example, let's consider the
      <code>EmployeeService</code> interface that we want all of our employee
      components to implement. This service provides one method to compute age
      based on a birth date passed as parameter. Whenever the passed-in date
      is null, the returned age will also be.</para>

      <para>Let's see how we can attach this service :</para>

      <para><programlisting language="xml">&lt;bean
  id="Employee"
  class="com.d2s.framework.model.descriptor.entity.basic.BasicEntityDescriptor"&gt;
  ...
  &lt;property name="serviceDelegates"&gt; <co id="serviceDelegates" />
    &lt;map&gt;
      &lt;entry key="com.d2s.framework.hrsample.model.service.EmployeeService"&gt; <co
            id="NameableService" />
        &lt;bean
          class="com.d2s.framework.hrsample.model.service.EmployeeServiceDelegate" /&gt; <co
            id="NameableServiceImpl" />
      &lt;/entry&gt;
    &lt;/map&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting><calloutlist>
          <callout arearefs="serviceDelegates">
            <para>We declare the services and their implementations attached
            to the <code>Employee</code> interface.</para>
          </callout>

          <callout arearefs="NameableService">
            <para>The <code>EmployeeService</code> interface.</para>
          </callout>

          <callout arearefs="NameableServiceImpl">
            <para>And its implementation delegate
            (<code>EmployeeService</code>Delegate).</para>
          </callout>
        </calloutlist>Of course, we have to code both
      <code>EmployeeService</code> (the service definition) and
      <code>EmployeeServiceDelegate</code> (the service delegate
      implementation) in the
      <code>com.d2s.framework.hrsample.model.service</code> package as
      described in the previous XML fragment.</para>

      <para>Here is the <filename>EmployeeService.java</filename> source file
      :</para>

      <para><programlisting>package com.d2s.framework.hrsample.model.service;

import java.util.Date;

/**
 * Services offered by the Employee entity.
 */
public interface EmployeeService {

  /**
   * Computes the employee age.
   * 
   * @param birthDate
   *            the employee birth date.
   * @return the computed age based on the birth date or null if the birt date
   *         is not available.
   */
  Integer computeAge(Date birthDate);
}</programlisting>And the <filename>EmployeeServiceDelegate.java</filename>
      source file :</para>

      <para><programlisting>package com.d2s.framework.hrsample.model.service;

import java.util.Date;

import com.d2s.framework.hrsample.model.Employee;
import com.d2s.framework.model.component.service.IComponentService;

/**
 * The services delegate of the Employee entity
 */
public class EmployeeServiceDelegate implements IComponentService { <co
            id="IComponentService" />

  /**
   * Computes the employee age.
   * 
   * @param employee
   *            the employee this service execution has been triggered on.
   * @param birthDate
   *            a birth date (might be different than the actual employee birth
   *            date).
   * @return the age computed from the birth date passed as parameter.
   */
  public Integer computeAge(Employee employee, Date birthDate) { <co
            id="fomatName" />
    if (birthDate != null) {
      return new Integer(
          (int) ((new Date().getTime() - birthDate.getTime()) / (1000L * 60 * 60 * 24 * 365)));
    }
    return null;
  }
}</programlisting><calloutlist>
          <callout arearefs="IComponentService">
            <para>We mark the delegate as implementing
            <code>IComponentService</code>.</para>
          </callout>

          <callout arearefs="fomatName">
            <para>We declare the method with the same name than the service
            method. The parameter list is the same than the service method
            with the target component instance to trigger the service on
            inserted at the beginning of the list.</para>
          </callout>
        </calloutlist>You will notice that
      <code>EmployeeServiceDelegate</code> does not itself implements
      <code>EmployeeService</code>. This is simply because although the names
      of the implemented methods must match, their signature is augmented by
      the component instance to work on. This allows the
      <trademark>D2S</trademark> framework to share services delegates across
      multiple component instances.</para>

      <para>A re-generation of the <filename>Employee.java</filename> source
      updates the <code>Employee</code> definition so that it now implements
      the <code>EmployeeService</code> interface :</para>

      <para><programlisting>...
public interface Employee extends
  com.d2s.framework.hrsample.model.Nameable,
  com.d2s.framework.hrsample.model.Traceable,
  com.d2s.framework.model.entity.IEntity,
  com.d2s.framework.hrsample.model.service.EmployeeService {
...
}</programlisting>Again, <trademark>D2S</trademark> will seamlessly take care
      of triggering the delegates' methods, passing the right parameters,
      whenever the service is requested on the target component.</para>
    </section>

    <section>
      <title>Computed properties</title>

      <para>Not all properties have a representation in the persistent store.
      Some of them may be computed using other parts of the domain model. For
      instance, in the <code>Employee</code> entity, the age property is one
      of them. It is fairly easy to compute the age of an employee from his
      birth date and this is the service we have just implemented above. Of
      course computed properties are not limited to entities. They can be
      declared on any <trademark>D2S</trademark> managed component (inlined
      components, interfaces and entities). And they are not limited to scalar
      properties. Even a collection property or a reference property may be
      computed this way.</para>

      <para>Let's see how we can link it using <trademark>D2S</trademark>
      :</para>

      <para><programlisting language="xml">&lt;bean
  id="Employee"
  class="com.d2s.framework.model.descriptor.entity.basic.BasicEntityDescriptor"&gt;
  ...
  &lt;property name="propertyDescriptors"&gt;
    &lt;list&gt;
      ...
      &lt;bean
        class="com.d2s.framework.model.descriptor.basic.BasicIntegerPropertyDescriptor"&gt;
        &lt;property
          name="name"
          value="age" /&gt;
        &lt;property
          name="minValue"
          value="0" /&gt;
        &lt;property
          name="maxValue"
          value="150" /&gt;
        &lt;property
          name="delegateClassName"
          value="com.d2s.framework.hrsample.model.extension.EmployeeExtension" /&gt; <co
            id="delegateClassName" />
      &lt;/bean&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting><calloutlist>
          <callout arearefs="delegateClassName">
            <para>We link the age property to a java class used to compute its
            value.</para>
          </callout>
        </calloutlist>As you can see in the above XML fragment, the age
      property is almost described like any other standard entity property.
      What differs is the reference to the
      <code>com.d2s.framework.hrsample.model.extension.EmployeeExtension</code>
      java class that will be used to compute it. So let's code it. As
      declared in the descriptor, we will put it in the
      <code>com.d2s.framework.hrsample.model.extension</code> package :</para>

      <para><programlisting language="java">package com.d2s.framework.hrsample.model.extension;

import java.util.Date;

import com.d2s.framework.hrsample.model.Employee;
import com.d2s.framework.model.component.AbstractComponentExtension;

/**
 * Helper class computing extended properties for Employee entity.
 */
public class EmployeeExtension extends
    AbstractComponentExtension&lt;Employee&gt; <co
            id="AbstractComponentExtension" /> {

  /**
   * Constructs a new &lt;code&gt;EmployeeExtension&lt;/code&gt; instance.
   * 
   * @param extendedEmployee
   *            The extended employee instance.
   */
  public EmployeeExtensionSimple(Employee extendedEmployee) {
    super(extendedEmployee);
  }

  /**
   * Computes the employee age.
   * 
   * @return The employee age.
   */
  public Integer getAge() { <co id="getAge" />
    return getComponent()<co id="getComponent" />.computeAge<co
            id="computeAge" />(getComponent().getBirthDate());
  }
}</programlisting><calloutlist>
          <callout arearefs="AbstractComponentExtension">
            <para>The employee extension class inherit from the
            <code>AbstractComponentExtension</code> framework base
            class.</para>
          </callout>

          <callout arearefs="getAge">
            <para>We implement the <code>getAge()</code> method which is
            triggered by the framework whenever the age property is accessed
            on an employee.</para>
          </callout>

          <callout arearefs="getComponent">
            <para>Note the use of the <code>getComponent()</code> method to
            retrieve the instance of employee this extension is attached to.
            This will be the starting point for exploring the domain model and
            computing arbitrary complex attributes.</para>
          </callout>

          <callout arearefs="computeAge">
            <para>We call the service method we have implemented in the
            previous chapter.</para>
          </callout>
        </calloutlist>Implementing the employee extension class as above is
      plainly licit but might lead to performance issues for more complex
      computations. In fact, each time the age property is requested, the
      <code>getAge()</code> method is triggered. This is not painful for the
      simple age implementation but imagine that you had to do a CPU or
      network consuming computation to return the computed property !</para>

      <para>Moreover, whenever the birth date is modified, no one is notified
      that the age changes since we did not implement anywhere the dependency
      "birth date â‡’ age".</para>

      <para>Pushing the analysis further shows that the age of an employee
      does not change until his birth date changes (which is very unlikely).
      So a more efficient implementation for the employee extension class
      consist in keeping the computed age value for later use and listening to
      changes of the birth date property to invalidate the age cached value.
      Hopefully, the implementation is almost straightforward since every
      <trademark>D2S</trademark> managed component can be listened to for
      property changes.</para>

      <para>The following update of the <filename>Employee.java</filename>
      source file fixes the 2 caveats described above :</para>

      <para><programlisting language="java">package com.d2s.framework.hrsample.model.extension;

import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.util.Date;

import com.d2s.framework.hrsample.model.Employee;
import com.d2s.framework.model.component.AbstractComponentExtension;
import com.d2s.framework.util.bean.IPropertyChangeCapable;

/**
 * Helper class computing extended properties for Employee entity.
 */
public class EmployeeExtension extends AbstractComponentExtension&lt;Employee&gt; {

  private Integer age = null; <co id="age" />

  /**
   * Constructs a new &lt;code&gt;EmployeeExtension&lt;/code&gt; instance.
   * 
   * @param extendedEmployee
   *            The extended Employee instance.
   */
  public EmployeeExtension(Employee extendedEmployee) {
    super(extendedEmployee);
    extendedEmployee.addPropertyChangeListener("birthDate", <co
            id="addPropertyChangeListener" />
        new PropertyChangeListener() {

          public void propertyChange(@SuppressWarnings("unused")
          PropertyChangeEvent evt) {
            Integer oldAge = age;
            age = null; <co id="ageReset" />
            getComponent().firePropertyChange("age", oldAge,
                IPropertyChangeCapable.UNKNOWN); <co id="firePropertyChange" />
          }
        });
  }

  /**
   * Computes the employee age.
   * 
   * @return The employee age.
   */
  public Integer getAge() {
    if (age != null) {
      return age; <co id="returnAge" />
    }
    age = getComponent().computeAge(getComponent().getBirthDate());
    return age;
  }
}</programlisting></para>

      <para><calloutlist>
          <callout arearefs="age">
            <para>The age cache attribute.</para>
          </callout>

          <callout arearefs="addPropertyChangeListener">
            <para>We attach to the birth date property to be notified of a
            change.</para>
          </callout>

          <callout arearefs="ageReset">
            <para>Whenever the birth date changes, we invalidate the age
            cache.</para>
          </callout>

          <callout arearefs="firePropertyChange">
            <para>And we notify listeners, if any, of the age property change.
            Note the use of the <code>UNKNOWN</code> constant. This is to
            avoid useless computations if there is no listener attached to the
            age property; the computation will only be triggered when the age
            property is actually requested.</para>
          </callout>

          <callout arearefs="returnAge">
            <para>Whenever the age cache is valid, return it. If it has not
            been computed yet or if the cache has just been invalidated,
            perform the computation.</para>
          </callout>
        </calloutlist>When re-generating the
      <filename>Employee.java</filename> source file, you will notice that the
      <code>getAge()</code> method will be added but without any hibernate
      xDoclet annotation since the age property is not related to the
      <code>Employee</code> persistence. Once again, the framework will
      completely take care of calling the delegate class whenever the age
      property is requested.</para>

      <para>The key advantages of this type of modularization are :</para>

      <itemizedlist>
        <listitem>
          <para>Easy switching between implementations. You might have a mock
          implementation for the early stage of the development and when the
          job is done, switch with the real one. You could also switch the
          implementations depending on the environment you deploy to.</para>
        </listitem>

        <listitem>
          <para>Clear separation of concerns allowing an efficient
          distribution of work between developers.</para>
        </listitem>

        <listitem>
          <para>Ease of monitoring and testing. The code responsible of the
          implementation can be easily instrumented.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Integrity processors</title>

      <para>A clean and efficient domain model design assigns to the business
      objects the responsibility of maintaining their integrity.</para>

      <para>This implies :</para>

      <orderedlist>
        <listitem>
          <para>Checking a property before it gets actually modified. Trying
          to set a value that would compromise the business object integrity
          must be prevented and should raise a clear notification.</para>
        </listitem>

        <listitem>
          <para>Triggering some extra computation when a property value gets
          actually updated.</para>
        </listitem>
      </orderedlist>

      <para>The first point is partially covered by some of the constraints
      that can be assigned on the property descriptors; assigning a maximum
      value to an integer property descriptor or a regular expression to a
      string property descriptor are such controls. Unfortunately, there are
      situations when these type of controls are not enough because, for
      instance, the integrity of the component is checked against its global
      state (a property value is constrained by the values of other properties
      of the business object or even of other business objects of the
      model).</para>

      <para>As far as the second point is concerned, we have seen nothing yet
      that would help to cover it.</para>

      <para>Fortunately, the <trademark>D2S</trademark> framework allows you
      to implement integrity processors that can be registered with any
      property you define on a <trademark>D2S</trademark> managed component.
      This includes :</para>

      <orderedlist>
        <listitem>
          <para>Pre-update integrity processors to cover pre-update controls
          on setters for scalar, reference and collection properties and
          adders and removers for collection properties.</para>
        </listitem>

        <listitem>
          <para>Post-update integrity processors to trigger post-update
          computations for scalar, reference and collection properties and
          adders and removers for collection properties.</para>
        </listitem>
      </orderedlist>

      <para>Let's define some simple integrity constraints on our domain model
      :</para>

      <itemizedlist>
        <listitem>
          <para>An employee first name should be automatically formatted like
          this : first letter capitalized and the remaining letters in lower
          case; this is a post-update integrity processor on the employee
          first name property. We could have implemented this constraint using
          a regular expression check, but this would have forced the end user
          to type-in a compliant first name instead of automatically making it
          compliant through computation.</para>
        </listitem>

        <listitem>
          <para>An employee can not be hired if he is not at least 18 years
          old; this is a pre-update integrity processor on the employee birth
          date property.</para>
        </listitem>
      </itemizedlist>

      <para>The following XML fragment declares these processors :</para>

      <para><programlisting language="xml">&lt;bean
  id="Employee"
  class="com.d2s.framework.model.descriptor.entity.basic.BasicEntityDescriptor"&gt;
  ...
  &lt;property name="propertyDescriptors"&gt;
    &lt;list&gt;
      &lt;bean
        class="com.d2s.framework.model.descriptor.basic.BasicStringPropertyDescriptor"&gt;
        &lt;property
          name="name"
          value="firstName" /&gt;
        ...
        &lt;property name="integrityProcessors"&gt; <co
            id="integrityProcessors" />
          &lt;list&gt;
            &lt;bean <co id="FirstNameIntegrityProcessor" />
              class="com.d2s.framework.hrsample.model.processor.EmployeeIntegrityProcessors$FirstNameIntegrityProcessor" /&gt;
          &lt;/list&gt;
        &lt;/property&gt;
      &lt;/bean&gt;
      ...
      &lt;bean
        class="com.d2s.framework.model.descriptor.basic.BasicDatePropertyDescriptor"&gt;
        &lt;property
          name="name"
          value="birthDate" /&gt;
        ...
        &lt;property name="integrityProcessors"&gt;
          &lt;list&gt;
            &lt;bean <co id="BirthDateIntegrityProcessor" />
              class="com.d2s.framework.hrsample.model.processor.EmployeeIntegrityProcessors$BirthDateIntegrityProcessor" /&gt;
          &lt;/list&gt;
        &lt;/property&gt;
      &lt;/bean&gt;
      ...
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting><calloutlist>
          <callout arearefs="integrityProcessors">
            <para>The property is completed by a list of integrity processors.
            Each processor of this chain will be triggered
            sequentially.</para>
          </callout>

          <callout arearefs="FirstNameIntegrityProcessor">
            <para>We register the processor on the first name property.</para>
          </callout>

          <callout arearefs="BirthDateIntegrityProcessor">
            <para>We register the processor on the birth date property.</para>
          </callout>
        </calloutlist></para>

      <para>As described in the XML fragment, we are going to create an
      <code>EmployeeIntegrityProcessors</code> class in the new package
      <code>com.d2s.framework.hrsample.model.processor</code>. As a best
      practice, it is recommended (but not imposed) to create a containing
      class that holds all the processors for a component; then each processor
      will be a named static internal class of this container class and
      referenced as such (using the $ sign) in the spring configuration file.
      This pattern limits the number of processors source files in the project
      while grouping all the processors related to a component
      together.</para>

      <para>Let's see what those processors look like by looking at the
      <filename>EmployeeIntegrityProcessors.java</filename> source file
      :</para>

      <para><programlisting language="java">package com.d2s.framework.hrsample.model.processor;

import java.util.Date;

import com.d2s.framework.hrsample.model.Employee;
import com.d2s.framework.util.bean.integrity.EmptyPropertyIntegrityProcessor;
import com.d2s.framework.util.bean.integrity.IntegrityException;

/**
 * Employee integrity processors.
 */
public class EmployeeIntegrityProcessors {

  /**
   * Birth date integrity processor.
   */
  public static class BirthDateIntegrityProcessor extends <co
            id="BirthDateIntegrityProcessorImpl" />
      EmptyPropertyIntegrityProcessor&lt;Employee, Date&gt; {

    /**
     * Checks that the employee age is at least 18.
     * &lt;p&gt;
     * {@inheritDoc}
     */
    @Override
    public void preprocessSetterIntegrity(Employee employee, <co
            id="preprocessSetterIntegrity" />
        @SuppressWarnings("unused")
        Date oldBirthDate, Date newBirthDate) {
      if (newBirthDate == null
          || employee.computeAge(newBirthDate).intValue() &lt; 18) {
        throw new IntegrityException("Age is below 18", "age.below.18"); <co
            id="IntegrityException" />
      }
    }
  }

  /**
   * First name integrity processor.
   */
  public static class FirstNameIntegrityProcessor extends <co
            id="FirstNameIntegrityProcessorImpl" />
      EmptyPropertyIntegrityProcessor&lt;Employee, String&gt; {

    /**
     * Formats the new first name. The formatting is :
     * &lt;li&gt;Capitalize the 1st letter
     * &lt;li&gt;Lower case all the other letters
     * &lt;p&gt;
     * {@inheritDoc}
     */
    @Override
    public void postprocessSetterIntegrity(Employee employee, <co
            id="postprocessSetterIntegrity" />
        @SuppressWarnings("unused")
        String oldFirstName, String newFirstName) {
      if (newFirstName != null &amp;&amp; newFirstName.length() &gt; 0) {
        StringBuffer formattedName = new StringBuffer();
        formattedName.append(newFirstName.substring(0, 1).toUpperCase());
        formattedName.append(newFirstName.substring(1).toLowerCase());
        employee.setFirstName(formattedName.toString()); <co
            id="formattedName" />
      }
    }
  }
}</programlisting><calloutlist>
          <callout arearefs="BirthDateIntegrityProcessorImpl">
            <para>We declare an internal class as being a processor for the
            birth date property and inherit from the
            <code>EmptyPropertyIntegrityProcessor</code> empty adaptor
            class.</para>
          </callout>

          <callout arearefs="preprocessSetterIntegrity">
            <para>We override the <code>preprocessSetterIntegrity</code> to
            implement the age over 18 constraint.</para>
          </callout>

          <callout arearefs="IntegrityException">
            <para>Whenever the condition is not met, we throw an
            <code>IntegrityException</code> to stop the chain and notify the
            outside that the property update could not be performed. The
            second parameter in the exception is a bundle key used for
            internationalization; this is not covered by this section.</para>
          </callout>

          <callout arearefs="FirstNameIntegrityProcessorImpl">
            <para>We declare an internal class as being a processor for the
            first name property and inherit from the
            <code>EmptyPropertyIntegrityProcessor</code> empty adaptor
            class.</para>
          </callout>

          <callout arearefs="postprocessSetterIntegrity">
            <para>We override the <code>postprocessSetterIntegrity</code> to
            implement the first name formatting.</para>
          </callout>

          <callout arearefs="formattedName">
            <para>We replace the first name in the employee by the new
            computed value.</para>
          </callout>
        </calloutlist>Each processor declared on a property is potentially a
      pre and post processor. To make a property processor a pre-only
      processor, just leave the <code>postprocessSetterIntegrity</code> method
      implementation empty. Same applies to make property processor a
      post-only processor by leaving the
      <code>preprocessSetterIntegrity</code> method implementation empty. We
      encourage you, as shown in the example above, to make all your
      processors inherit from the <code>EmptyPropertyIntegrityProcessor</code>
      adapter class which provide empty implementations for both methods and
      then to override the method you want to provide an implementation
      for.</para>
    </section>
  </section>

  <section>
    <title>Describing the views</title>

    <para>Now that we designed the complete domain model, it is time to make
    it available to the end-user. So we need to design the views that will be
    part of our application. As promised, we won't need a single line of GUI
    code to achieve that. As for the domain model description, the goal will
    be :</para>

    <orderedlist>
      <listitem>
        <para>To define precisely what we want.</para>
      </listitem>

      <listitem>
        <para>To assemble descriptor beans in order to translate what has been
        specified into <trademark>D2S</trademark> view descriptors.</para>
      </listitem>
    </orderedlist>

    <para>As far as we begin to deal with GUI, internationalization (I18N)
    comes into the game. <trademark>D2S</trademark> is definitely targeted at
    multi-lingual applications and as such, fully supports internationalized
    GUIs.</para>

    <para>Before going further, let's create the frontend application
    descriptor. The frontend description will logically go to the
    <code>com.d2s.framework.hrsample.frontend</code> package. In this package,
    we will create a <filename>hrsample-frontend.xml</filename> file as
    described below :</para>

    <para><programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans
  xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.springframework.org/schema/beans
                      http://www.springframework.org/schema/beans/spring-beans-2.0.xsd"
  default-lazy-init="true"&gt;

  &lt;!--
   The application I18N resources. 
  --&gt;
  &lt;bean
    id="applicationMessageSource"
    class="org.springframework.context.support.ResourceBundleMessageSource"&gt;
    &lt;property
      name="parentMessageSource"
      ref="commonsMessageSource" /&gt; <co id="commonsMessageSource" />
    &lt;property name="basenames"&gt;
      &lt;list&gt;
        &lt;value&gt;com.d2s.framework.hrsample.i18n.Messages&lt;/value&gt; <co
          id="basenames" />
      &lt;/list&gt;
    &lt;/property&gt;
  &lt;/bean&gt;
&lt;/beans&gt;</programlisting><calloutlist>
        <callout arearefs="commonsMessageSource">
          <para>We inherit the default <trademark>D2S</trademark> I18N
          resource bundles that contain translated entries for generic
          terms.</para>
        </callout>

        <callout arearefs="basenames">
          <para>We declare the list of I18N resource bundles we are going to
          use to store the translations.</para>
        </callout>
      </calloutlist><trademark>D2S</trademark> relies on the well-known java
    I18N mechanism through the use of resource bundle property files.
    Translating the application is then a matter of translating the entries
    contained in these property files. Since <trademark>D2S</trademark> never
    use absolute positioning but instead heavily relies on layouts, the
    translator won't have to care about translations length.</para>

    <para>As declared in the XML fragment above, we will create a
    <code>com.d2s.framework.hrsample.i18n</code> package that will contain the
    resource bundle property files. We will translate the application in
    English and French; so let's create the two files
    <filename>Messages_en.properties</filename> and
    <filename>Messages_fr.properties</filename> that will respectively contain
    the English and French translations. Adding a language will be just a
    mater of creating, in the same package, a new property file with the 2
    letter ISO code of the language. Those 2 files are empty as of now but
    don't care about that; <trademark>D2S</trademark> will graphically notify
    you that a translation is missing for a given language.</para>

    <para>In order to ease the work of the GUI designer,
    <trademark>D2S</trademark> provides a view tester tool that enables an
    immediate java swing preview of each described view fragment. In order to
    have this tool up and running, we need to create a new entry in the
    <filename>beanRefFactory.xml</filename> file we created when designing the
    domain model as below :</para>

    <para><programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans
  xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.springframework.org/schema/beans
                      http://www.springframework.org/schema/beans/spring-beans-2.0.xsd"
  default-lazy-init="true"&gt;
  ...
  &lt;bean
    id="hrsample-viewtester-context"
    class="org.springframework.context.support.ClassPathXmlApplicationContext"
    lazy-init="true"&gt;
    &lt;constructor-arg&gt;
      &lt;list&gt;
        &lt;value&gt;com/d2s/framework/application/commons.xml&lt;/value&gt;
        &lt;value&gt;com/d2s/framework/tools/mock.xml&lt;/value&gt;
        &lt;value&gt;com/d2s/framework/hrsample/model/hrsample-model.xml&lt;/value&gt; <co
          id="hrsample-model.xml" />
        &lt;value&gt;com/d2s/framework/application/frontend/commons-frontend.xml&lt;/value&gt; <co
          id="commons-frontend.xml" />
        &lt;value&gt;com/d2s/framework/application/frontend/swing/commons-swing.xml&lt;/value&gt; <co
          id="commons-swing.xml" />
        &lt;value&gt;com/d2s/framework/hrsample/frontend/hrsample-frontend.xml&lt;/value&gt; <co
          id="hrsample-frontend.xml" />
      &lt;/list&gt;
    &lt;/constructor-arg&gt;
  &lt;/bean&gt;
&lt;/beans&gt;</programlisting><calloutlist>
        <callout arch="" arearefs="hrsample-model.xml">
          <para>Our sample application domain model description.</para>
        </callout>

        <callout arearefs="commons-frontend.xml">
          <para>The commons frontend bean definitions of the
          <trademark>D2S</trademark> framework.</para>
        </callout>

        <callout arearefs="commons-swing.xml">
          <para>The commons swing bean definitions of the
          <trademark>D2S</trademark> framework.</para>
        </callout>

        <callout arearefs="hrsample-frontend.xml">
          <para>Our sample application frontend description.</para>
        </callout>
      </calloutlist>In order to start the <trademark>D2S</trademark> view
    tester tool, we will launch the
    <code>com.d2s.framework.tools.viewtester.ViewTester</code> java class with
    the following arguments : <code>-applicationContextKey
    hrsample-viewtester-context -viewId &lt;view descriptor id&gt; -language
    en</code>.</para>

    <para>The application context key used above is the one we have just added
    in the <filename>beanRefFactory.xml</filename> configuration file. Note
    that you are able to choose the language to use for displaying the tested
    view through the use of the <code>-language</code> option. Whenever this
    option is omitted, the view tester will fall back to the platform default
    locale. Changing the language when testing a view will allow for early
    missing translations identification.</para>

    <para>Finally, note that the view tester tool will not display fully
    functional views. For instance, list of values won't be available (the
    button will be displayed but won't trigger anything) since the view is not
    instantiated in the scope of a complete <trademark>D2S</trademark>
    application - no database, ... Its goal is only targeted at quickly
    previewing the GUI layout to promote agile development.</para>

    <para>We can now begin to describe our first views.</para>

    <section>
      <title>Component views</title>

      <para>One of the most heavily used type of view is the form-like
      component view. We will see in this section how to describe, translate
      and further customize a component view.</para>

      <section>
        <title>The first shot</title>

        <para>Let's describe our first component view on the company entity in
        the <filename>hrsample-frontend.xml</filename> file:</para>

        <para><programlisting>&lt;bean
  id="Company.pane"
  parent="decoratedView" <co id="decoratedView" />
  class="com.d2s.framework.view.descriptor.basic.BasicComponentViewDescriptor"&gt; <co
              id="BasicComponentViewDescriptor" />
  &lt;property
    name="labelsPosition"
    ref="ABOVE" /&gt; <co id="labelsPosition" />
  &lt;property
    name="columnCount"
    value="3" /&gt; <co id="columnCount" />
  &lt;property
    name="modelDescriptor"
    ref="Company" /&gt; <co id="modelDescriptor" />
&lt;/bean&gt;</programlisting><calloutlist>
            <callout arearefs="decoratedView">
              <para>We inherit from a D2S standard bean which surrounds the
              view with a title.</para>
            </callout>

            <callout arearefs="BasicComponentViewDescriptor">
              <para>We want a form-like component view.</para>
            </callout>

            <callout arearefs="labelsPosition">
              <para>We want each property label to be positioned above the
              property field. We could have used the <code>ASIDE</code>
              constant to indicate that we wanted the labels aside the
              fields.</para>
            </callout>

            <callout arearefs="columnCount">
              <para>We want the component view to be organized in 3
              columns.</para>
            </callout>

            <callout arearefs="modelDescriptor">
              <para>We refer to the company descriptor we described in the
              previous section.</para>
            </callout>
          </calloutlist>Although there are plenty of configurations that can
        be applied to view descriptions (font, color, properties subset, ...),
        the previous XML fragment is fully enough to get our first view up and
        running using the view tester. Note that unlike for the model
        components, there is no java generation nor compilation step involved;
        the view descriptors are just handled at runtime by
        <trademark>D2S</trademark>. Launching the tester with the
        <code>Company.pane</code> view descriptor id will produce the
        following result :</para>

        <para><figure>
            <title>The first component view</title>

            <mediaobject>
              <imageobject>
                <imagedata align="center" contentdepth="60%"
                           fileref="../images/Company.pane.jpg" scalefit="1"
                           width="100%" />
              </imageobject>
            </mediaobject>
          </figure>You will notice several things on the screen shot above
        :</para>

        <itemizedlist>
          <listitem>
            <para>The <code>name</code> label has been colored in red and has
            a star marker. It is to indicate that the name property is
            mandatory as declared during the <link linkend="n-mand">domain
            model design</link>.</para>
          </listitem>

          <listitem>
            <para>The <code>createTimestamp</code> and
            <code>lastUpdateTimestamp</code> property fields have been made
            non-editable as <link linkend="readOnly">we declared
            them</link>.</para>
          </listitem>

          <listitem>
            <para>The <code>contact</code> inlined component has been splitted
            into its 4 properties (<code>address</code>, <code>city</code>,
            <code>phone</code> and <code>email</code>). The component
            properties are referred to using a nested property notation like
            <emphasis>component.property</emphasis>.</para>
          </listitem>

          <listitem>
            <para>The <code>city</code> property field has been added a list
            of value (LOV) button. This button will bring a dialog box
            allowing the user to look-up available cities and select
            one.</para>

            <para><screenshot>
                <screeninfo>City LOV</screeninfo>

                <mediaobject>
                  <imageobject>
                    <imagedata align="center" contentdepth="60%"
                               fileref="../images/Lov.jpg" scalefit="1"
                               width="100%" />
                  </imageobject>
                </mediaobject>
              </screenshot>Of course, leaving the field with an incomplete
            value would auto-complete the value if the typed-in string is
            sufficient to determine one and only one city or bring up the LOV
            dialog without for the user to push the LOV button. This reference
            field behaviour is only the consequence of having declared the
            <code>ContactInfo</code> -&gt; <code>City</code> <link
            linkend="BasicReferencePropertyDescriptor">relationship</link>. In
            the view tester tool, the search button and the auto-completion
            are not functional since we don't have any backend to rely
            on.</para>
          </listitem>

          <listitem>
            <para>Whenever you try to type-in "aze" in the email property
            field, you will obtain the following error message :</para>

            <para><screenshot>
                <screeninfo>Regular expression error message</screeninfo>

                <mediaobject>
                  <imageobject>
                    <imagedata align="center" contentdepth="60%"
                               fileref="../images/regexp_error.jpg"
                               scalefit="1" width="100%" />
                  </imageobject>
                </mediaobject>
              </screenshot>This is due to the <link
            linkend="regexpPattern">constraint we applied on the email
            property</link> in the <code>ContactInfo</code> inlined
            component.</para>
          </listitem>

          <listitem>
            <para>Finally, there are terms that are missing translations in
            English. Whenever <trademark>D2S</trademark> detects such a
            situation, it will "translate" the term using the following
            pattern <emphasis>[language:translation key]</emphasis>. This
            strategy allows for easy and fast identification of missing
            translations. You will also notice that the name label has been
            correctly translated. This is because "name" is part of the <link
            linkend="commonsMessageSource">default translations</link>. Of
            course, you may override this translation if you wish in the
            application I18N property files.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Internationalization</title>

        <para>To complete the view design, we are going to translate the
        missing terms in the I18N property files we've opened previously. To
        ease the editing of the I18N property files, we recommend the use of a
        very good Eclipse plug in : the <ulink
        url="http://www.resourcebundleeditor.com">Resource Bundle
        Editor</ulink>.</para>

        <para>For instance, <filename>Messages_en.properties</filename> could
        be :</para>

        <para><programlisting>age.below.18 = Employee is not 18 years old.

com.d2s.framework.hrsample.model.Company = Company

contact.address = Address
contact.city    = City
contact.email   = Email
contact.phone   = Phone

createTimestamp = Created

hrsample.name = Human Resources management

lastUpdateTimestamp = Updated

zip = Code postal</programlisting>And Messages_fr.properties :</para>

        <para><programlisting>age.below.18 = L'employ\u00E9 n'a pas 18 ans.

com.d2s.framework.hrsample.model.Company = Soci\u00E9t\u00E9

contact.address = Adresse
contact.city    = Ville
contact.email   = Email
contact.phone   = T\u00E9l\u00E9phone

createTimestamp = Cr\u00E9\u00E9 le

hrsample.name = Gestion des ressources humaines

lastUpdateTimestamp = Mis \u00E0 jour le

zip = Zip code</programlisting>Relaunching the view test with the English
        locale will produce :<figure>
            <title>Company view with English translation</title>

            <mediaobject>
              <imageobject>
                <imagedata align="center" contentdepth="60%"
                           fileref="../images/Company.pane_en.jpg"
                           scalefit="1" width="100%" />
              </imageobject>
            </mediaobject>
          </figure></para>

        <para>And with the French locale :<figure>
            <title>Company view with French translation</title>

            <mediaobject>
              <imageobject>
                <imagedata align="center" contentdepth="60%"
                           fileref="../images/Company.pane_fr.jpg"
                           scalefit="1" width="100%" />
              </imageobject>
            </mediaobject>
          </figure></para>
      </section>

      <section>
        <title>Customization</title>

        <para>We certainly need to further customize the company view. This
        includes :</para>

        <itemizedlist>
          <listitem>
            <para>Selecting the properties we want to display.</para>
          </listitem>

          <listitem>
            <para>Ordering the displayed properties.</para>
          </listitem>

          <listitem>
            <para>Spanning properties across multiple columns.</para>
          </listitem>
        </itemizedlist>

        <para>Assume that we would like to hide the tracing properties since,
        after all, they are technical data. Then, we want to organize the
        fields in 2 columns instead of 3 having the company name to span over
        the 2 columns. Then we keep the order name, address, city, phone and
        email.</para>

        <para>The following modification to the view descriptor achieves that
        :</para>

        <para><programlisting>&lt;bean
  id="Company.pane"
  parent="decoratedView"
  class="com.d2s.framework.view.descriptor.basic.BasicComponentViewDescriptor"&gt;
  ...
  &lt;property
    name="columnCount"
    value="2" /&gt; <co id="columnCount_2" />
  ...
  &lt;property name="propertyViewDescriptors"&gt; <co
              id="propertyViewDescriptors" />
    &lt;list&gt;
      &lt;bean
        class="com.d2s.framework.view.descriptor.basic.BasicSubviewDescriptor"&gt;
        &lt;property
          name="name"
          value="name" /&gt;
      &lt;/bean&gt;
      &lt;bean
        class="com.d2s.framework.view.descriptor.basic.BasicSubviewDescriptor"&gt;
        &lt;property
          name="name"
          value="contact.address" /&gt;
      &lt;/bean&gt;
      &lt;bean
        class="com.d2s.framework.view.descriptor.basic.BasicSubviewDescriptor"&gt;
        &lt;property
          name="name"
          value="contact.city" /&gt;
      &lt;/bean&gt;
      &lt;bean
        class="com.d2s.framework.view.descriptor.basic.BasicSubviewDescriptor"&gt;
        &lt;property
          name="name"
          value="contact.phone" /&gt;
      &lt;/bean&gt;
      &lt;bean
        class="com.d2s.framework.view.descriptor.basic.BasicSubviewDescriptor"&gt;
        &lt;property
          name="name"
          value="contact.email" /&gt;
      &lt;/bean&gt;
    &lt;/list&gt;
  &lt;/property&gt;
  &lt;property name="propertyWidths"&gt; <co id="propertyWidths" />
    &lt;map&gt;
      &lt;entry
        key="name"
        value="2" /&gt;
    &lt;/map&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting></para>

        <para><calloutlist>
            <callout arearefs="columnCount_2">
              <para>We reduce the number of columns to 2.</para>
            </callout>

            <callout arearefs="propertyViewDescriptors">
              <para>We declare an ordered list of sub-view descriptors that
              contains the properties we want to display.</para>
            </callout>

            <callout arearefs="propertyWidths">
              <para>We assign width (columns span) to properties we don't want
              to have the default value of 1.</para>
            </callout>
          </calloutlist>Relaunching the view tester will produce the following
        output :</para>

        <para><figure>
            <title>The customized company view</title>

            <mediaobject>
              <imageobject>
                <imagedata align="center" contentdepth="60%"
                           fileref="../images/Company.pane_reworked.jpg"
                           scalefit="1" width="100%" />
              </imageobject>
            </mediaobject>
          </figure></para>

        <para>You will notice that the name field is now alone on its line,
        spanning over the 2 columns of the view. Of course, the tracing
        properties have disappeared from the view.</para>

        <para>There would have been another way to customize subset of
        displayed properties for the company entity. We could have set on the
        <code>Company</code> entity descriptor the
        <code>renderedProperties</code> attribute that allows to set an
        ordered list of properties to be displayed by default when an company
        instance is displayed in any view. This modification would have
        impacted all the application company views (including tables for
        instance) except the ones declare their own property list.</para>

        <para>To summarize, a component view will display (higher in the list
        has higher priority) :</para>

        <orderedlist>
          <listitem>
            <para>If set on the view, the
            <code>propertyViewDescriptors</code>.</para>
          </listitem>

          <listitem>
            <para>If set on the model, the
            <code>renderedProperties</code>.</para>
          </listitem>

          <listitem>
            <para>All the properties, in their declaration order except the
            collection properties. In that case, the inlined components are
            splitted as we saw it for the first shot.</para>
          </listitem>
        </orderedlist>
      </section>
    </section>

    <section>
      <title>Composite views</title>

      <para>Now that we have seen how to provide the end-user with basic
      component editing, we need to compose these views into more complex
      ones. As an example, let's say that you would like to have the tracing
      properties back in the company view, but in a separated panel so that
      the main screen is not overloaded by fields that are not useful at first
      sight. A classic way go is to introduce tabs with the tracing properties
      available in a secondary tab.</para>

      <section>
        <title>The first composite view</title>

        <para>Such a tab panel is called a composite view; its objective is to
        assemble sub-views into a more user-friendly graphical structure. In
        the following XML fragment, we will describe the component view to
        display the tracing properties and assemble the company view and the
        tracing view into a tab composite view :</para>

        <para><programlisting language="xml">&lt;bean
  id="Traceable.pane"
  parent="decoratedView"
  class="com.d2s.framework.view.descriptor.basic.BasicComponentViewDescriptor"&gt; <co
              id="Traceable.pane" />
  &lt;property
    name="labelsPosition"
    ref="ABOVE" /&gt;
  &lt;property
    name="columnCount"
    value="2" /&gt;
  &lt;property
    name="modelDescriptor"
    ref="Traceable" /&gt; <co id="modelDescriptor-traceable" />
  &lt;property name="propertyViewDescriptors"&gt;
    &lt;list&gt;
      &lt;bean
        class="com.d2s.framework.view.descriptor.basic.BasicSubviewDescriptor"&gt;
        &lt;property
          name="name"
          value="createTimestamp" /&gt;
      &lt;/bean&gt;
      &lt;bean
        class="com.d2s.framework.view.descriptor.basic.BasicSubviewDescriptor"&gt;
        &lt;property
          name="name"
          value="lastUpdateTimestamp" /&gt;
      &lt;/bean&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;
...
&lt;bean
  id="Company.tab.pane"
  class="com.d2s.framework.view.descriptor.basic.BasicTabViewDescriptor"&gt; <co
              id="BasicTabViewDescriptor" />
  &lt;property
    name="modelDescriptor"
    ref="Company" /&gt;
  &lt;property name="viewDescriptors"&gt; <co id="viewDescriptors-tab" />
    &lt;list&gt;
      &lt;ref local="Company.pane" /&gt;
      &lt;ref local="Traceable.pane" /&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting><calloutlist>
            <callout arearefs="Traceable.pane">
              <para>We describe a new component view descriptor for the
              tracing properties.</para>
            </callout>

            <callout arearefs="modelDescriptor-traceable">
              <para>You may notice that the model descriptor declared for this
              new component view descriptor is <code>Traceable</code> and not
              <code>Company</code>. The consequence is that this tracing view
              will be usable for all traceable components and not only
              companies; we leverage the polymorphic nature of the domain
              components.</para>
            </callout>

            <callout arearefs="BasicTabViewDescriptor">
              <para>We want a tab composite view.</para>
            </callout>

            <callout arearefs="viewDescriptors-tab">
              <para>We give an ordered list of views to be displayed in the
              tabs. Of course, these sub-views may be any type of view,
              including other composite views.</para>
            </callout>
          </calloutlist>After having completed the I18N property files with
        the <code>com.d2s.framework.hrsample.model.Traceable</code> entry, we
        can launch the view tester on the <code>Company.tab.pane</code> view
        :</para>

        <para><figure>
            <title>The tabbed company view</title>

            <mediaobject>
              <imageobject>
                <imagedata align="center" contentdepth="60%"
                           fileref="../images/Company.tab.pane.jpg"
                           scalefit="1" width="100%" />
              </imageobject>
            </mediaobject>
          </figure></para>
      </section>

      <section>
        <title>Improving the view aspect</title>

        <para>We can make the view a little more attractive by adding icons
        and tool tips. Using <trademark>D2S</trademark>, it is quite
        straightforward by completing the descriptors :</para>

        <itemizedlist>
          <listitem>
            <para>For the icons, we want to assign an image to the model
            components themselves so that whenever one of them is used as
            model, the framework may decide to use the image to improve the
            view appearance.</para>
          </listitem>

          <listitem>
            <para>For the tool tips, it is more link to the user interface
            itself, so we will declare it on the view; but in fact, we will
            not declare a tool tip as such but rather bring a description
            information to the view so that the framework may, at runtime,
            transform this description as a tool tip.</para>
          </listitem>
        </itemizedlist>

        <para>The following XML fragment assigns an icon image to the
        <code>Company</code> and the <code>Traceable</code> components
        :</para>

        <para><programlisting language="xml">&lt;bean
  id="Traceable"
  class="com.d2s.framework.model.descriptor.basic.BasicInterfaceDescriptor"&gt;
  ...
  &lt;property
    name="iconImageURL"
    value="classpath:com/d2s/framework/hrsample/images/traceable-48x48.png" /&gt; <co
              id="iconImageURL" />
&lt;/bean&gt;
...
&lt;bean
  id="Company"
  class="com.d2s.framework.model.descriptor.entity.basic.BasicEntityDescriptor"&gt;
  ...
  &lt;property
    name="iconImageURL"
    value="classpath:com/d2s/framework/hrsample/images/company-48x48.png" /&gt;
&lt;/bean&gt;</programlisting><calloutlist>
            <callout arearefs="iconImageURL">
              <para>We declare the URL used to reference the image to be used
              to represent a traceable component. Same applies for the
              company.</para>
            </callout>
          </calloutlist>And we assign a more friendly description to both
        component views. As for every potentially displayed string, these
        descriptions are entries in the I18N property files that we will
        translate. The following XML fragments achieves that :</para>

        <para><programlisting language="xml">&lt;bean
  id="Traceable.pane"
  parent="decoratedView"
  class="com.d2s.framework.view.descriptor.basic.BasicComponentViewDescriptor"&gt;
  ...
  &lt;property
    name="description"
    value="traceable.editing"&gt; <co id="traceable.editing" />
  &lt;/property&gt;
&lt;/bean&gt;
...
&lt;bean
  id="Company.pane"
  parent="decoratedView"
  class="com.d2s.framework.view.descriptor.basic.BasicComponentViewDescriptor"&gt;
  ...
  &lt;property
    name="description"
    value="company.editing"&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting><calloutlist>
            <callout arearefs="traceable.editing">
              <para>We declare an I18N entry to describe the traceable
              component view. Same applies for the company component
              view.</para>
            </callout>
          </calloutlist>Re-launching the view tester displays the following
        window :</para>

        <para><figure>
            <title>The improved tab company view</title>

            <mediaobject>
              <imageobject>
                <imagedata align="center" contentdepth="60%"
                           fileref="../images/Company.tab.pane_reworked.jpg"
                           scalefit="1" width="100%" />
              </imageobject>
            </mediaobject>
          </figure></para>

        <para>There are several remarks regarding what we have just done
        :</para>

        <itemizedlist>
          <listitem>
            <para>Name, description and icons can be used in different layers
            of the application. <trademark>D2S</trademark> will then take
            advantage of these attributes to generate tool tips, to place
            icons, to fill-in labels in the following order (higher in the
            list has higher priority) :</para>

            <orderedlist>
              <listitem>
                <para>Name, description and icon image URL (each attribute can
                be independently overridden) set on the view
                descriptor.</para>
              </listitem>

              <listitem>
                <para>Name, description and icon image URL set the model
                descriptor on which the view descriptor relies.</para>
              </listitem>
            </orderedlist>
          </listitem>

          <listitem>
            <para>To reference an image to be used as icon, you may use any
            kind of URL (HTTP, file) but <trademark>D2S</trademark> provides a
            very useful, specialized URL which is the <code>classpath:</code>
            URL. Such a URL may be used to reference any resource present in
            the application classpath. As an example, we have used the
            <code>classpath:com/d2s/framework/hrsample/images/company-48x48.png</code>
            URL to load an image from the
            <code>com.d2s.framework.hrsample.images</code> package. This
            prevents the developer from hard-coding references to application
            external resources and promotes portability across deployment
            environments.</para>
          </listitem>

          <listitem>
            <para>Whenever you want to link an icon image to a component or a
            view, you don't have to care about the actual size of the image.
            The framework will dynamically resize it for you at runtime,
            depending of what it wants to use it for. As a general rule, you
            might consider using little over sized images (48x48 is a good
            compromise) since image reduction won't degrade quality whereas
            image expansion will.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Other composite views</title>

        <para><trademark>D2S</trademark> offers a rich set of composite view
        descriptors. Although we won't detail them in this section, the
        following enumeration lists them :</para>

        <itemizedlist>
          <listitem>
            <para><code>BasicTabViewDescriptor</code> (we've just used it) to
            organize sub-views in tabs.</para>
          </listitem>

          <listitem>
            <para><code>BasicBorderViewDescriptor</code> to layout up to 5
            sub-views at north, south, east, west and center.</para>
          </listitem>

          <listitem>
            <para><code>BasicSplitViewDescriptor</code> to layout 2 sub-view
            within a separator splitted panel. The orientation of the split
            may be vertical or horizontal.</para>
          </listitem>

          <listitem>
            <para><code>BasicEvenGridViewDescriptor</code> to layout an
            arbitrary number of sub-views into a grid with equally sized
            cells. As for component views, you only set up the driving
            dimension (horizontal or vertical), the maximum number of cells in
            the driving dimension and an ordered list of the sub-views to be
            contained in the cells. Whenever the line (or column) reaches the
            maximum number of cells allowed, a new line (or column) is
            created.</para>
          </listitem>

          <listitem>
            <para><code>BasicConstrainedGridViewDescriptor</code> lets you
            organize sub-views in a grid where each cell behaviour is
            determined by the following attributes :</para>

            <itemizedlist>
              <listitem>
                <para>position (row, column)</para>
              </listitem>

              <listitem>
                <para>height (row span) and width (column span)</para>
              </listitem>

              <listitem>
                <para>width resizability and height resizability</para>
              </listitem>
            </itemizedlist>

            <para>This is certainly the most complex composite view descriptor
            but also the most powerful one.</para>
          </listitem>
        </itemizedlist>
      </section>
    </section>

    <section>
      <title>Collection views</title>

      <para>The next step in our frontend development is to display (and edit)
      collection relationships between components. We will achieve this using
      collection views; these type of views include multi-column table views
      and list views. In this section, you will learn how to build a
      multi-level master-detail view on the company structure.</para>

      <section>
        <title>The first collection view</title>

        <para>We need to give access to the end-user a mean to edit the
        departments contained in a company. As we defined it in the domain
        model, there is a 1-N relationship between the two so we will design a
        table view that displays 1 department per row and link this view to
        the company one.</para>

        <para>Let's consider the following XML fragment :</para>

        <para><programlisting language="xml">&lt;bean
  id="Company-departments.table"
  parent="decoratedView"
  class="com.d2s.framework.view.descriptor.basic.BasicTableViewDescriptor"&gt; <co
              id="BasicTableViewDescriptor" />
  &lt;property
    name="modelDescriptor"
    ref="Company-departments" /&gt; <co id="Company-departments-model" />
&lt;/bean&gt;

&lt;bean
  id="Company.organization.view"
  class="com.d2s.framework.view.descriptor.basic.BasicSplitViewDescriptor"&gt; <co
              id="BasicSplitViewDescriptor" />
  &lt;property
    name="modelDescriptor"
    ref="Company" /&gt; <co id="Company-model" />
  &lt;property
    name="leftTopViewDescriptor"
    ref="Company.tab.pane" /&gt; <co id="leftTopViewDescriptor" />
  &lt;property
    name="rightBottomViewDescriptor"
    ref="Company-departments.table" /&gt; <co id="rightBottomViewDescriptor" />
&lt;/bean&gt;</programlisting><calloutlist>
            <callout arearefs="BasicTableViewDescriptor">
              <para>We describe a table view.</para>
            </callout>

            <callout arearefs="Company-departments-model">
              <para>Unlike component views, collection views are backed by the
              N end of a 1-N relationship. Here, we reference the
              <code>Company</code> -&gt; <code>Department</code> relationship
              we've previously declared in the domain model.</para>
            </callout>

            <callout arearefs="BasicSplitViewDescriptor">
              <para>We organize the departments table view and the company
              view in a new type of composite view : a split view.</para>
            </callout>

            <callout arearefs="Company-model">
              <para>This composite view is still a view backed by a
              company.</para>
            </callout>

            <callout arearefs="leftTopViewDescriptor">
              <para>The top part of the split view is the company component
              view.</para>
            </callout>

            <callout arearefs="rightBottomViewDescriptor">
              <para>The bottom part of the split view is the departments table
              view.</para>
            </callout>
          </calloutlist></para>

        <para>After adding the necessary translations as usual, and linking a
        new icon to describe the department entities, re-launching the view
        tester produces the following window :</para>

        <para><figure>
            <title>The company and departments view</title>

            <mediaobject>
              <imageobject>
                <imagedata align="center" contentdepth="60%"
                           fileref="../images/Company.organization.view.jpg"
                           scalefit="1" width="100%" />
              </imageobject>
            </mediaobject>
          </figure>Of course, this is not enough to be able to manage the
        departments of a company. We are missing a way to add ad remove
        departments.</para>
      </section>

      <section>
        <title>Assigning an action map to a view</title>

        <para>Each view can be assigned an action map. An action map is a set
        of actions grouped by category. Consider an application menu bar. In
        this menu bar, you will find menus -action categories- like "File",
        "Edit", "Help" and in each menu, a list of individual actions. This is
        the exact same principle of an action map, but instead of being a
        rendered as a menu bar, the <trademark>D2S</trademark> framework will
        make a tool bar out of it, and in certain situations a context menu,
        that will make the actions available to the end user.</para>

        <para>In this section, we won't go describe in detail how to develop
        and declare an action. Actually, <trademark>D2S</trademark> comes with
        a large set of pre-defined, ready-to-use general purpose actions (and
        even action maps) that are sufficient for most classic operations.
        Look at the following XML fragment :</para>

        <para><programlisting language="xml">  &lt;bean
    id="Company-departments.table"
    parent="decoratedView"
    class="com.d2s.framework.view.descriptor.basic.BasicTableViewDescriptor"&gt;
    ...
    &lt;property
      name="actionMap"
      ref="masterDetailActionMap" /&gt; <co id="masterDetailActionMap" />
  &lt;/bean&gt;</programlisting><calloutlist>
            <callout arearefs="masterDetailActionMap">
              <para>We assign the predefined master-detail action map to the
              departments table view.</para>
            </callout>
          </calloutlist>These 3 new XML lines bring us what we need to be able
        to operate efficiently the company departments relationship.
        Re-launching the view tester modifies the previous view :</para>

        <para><figure>
            <title>The improved company and departments view</title>

            <mediaobject>
              <imageobject>
                <imagedata align="center" contentdepth="60%"
                           fileref="../images/Company.organization.view_reworked.jpg"
                           scalefit="1" width="100%" />
              </imageobject>
            </mediaobject>
          </figure></para>

        <para>Using this improved master detail view, we are now able to
        completely manage the departments of a company :</para>

        <itemizedlist>
          <listitem>
            <para>We can add, remove and duplicate a department.</para>
          </listitem>

          <listitem>
            <para>We copy, cut and paste a department.</para>
          </listitem>
        </itemizedlist>

        <para>Of course, we might need to refine and re-order the department
        properties displayed in the table view. Do you remember what we did
        previously for the company component view ? We will do the same for
        the departments table collection view, but instead of working directly
        on the view, we will rework the department entity itself globally set
        its rendered properties; whenever we need a department based view to
        be customized differently, we still have the option to override this
        global setting on the view descriptor itself. So let's go back to the
        department entity descriptor :</para>

        <para><programlisting language="xml">&lt;bean
  id="Department"
  class="com.d2s.framework.model.descriptor.entity.basic.BasicEntityDescriptor"&gt;
  ...
  &lt;property name="renderedProperties"&gt; <co id="renderedProperties" />
    &lt;list&gt;
      &lt;value&gt;ouId&lt;/value&gt;
      &lt;value&gt;name&lt;/value&gt;
      &lt;value&gt;manager&lt;/value&gt;
      &lt;value&gt;contact.address&lt;/value&gt;
      &lt;value&gt;contact.city&lt;/value&gt;
      &lt;value&gt;contact.phone&lt;/value&gt;
      &lt;value&gt;contact.email&lt;/value&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting></para>

        <para><calloutlist>
            <callout arearefs="renderedProperties">
              <para>We set the ordered list of department default rendered
              properties.</para>
            </callout>
          </calloutlist>And when we re-launch the view tester :</para>

        <para><figure>
            <title>The improved company and departments view with refined
            department columns</title>

            <mediaobject>
              <imageobject>
                <imagedata align="center" contentdepth="60%"
                           fileref="../images/Company.organization.view_reworked_2.jpg"
                           scalefit="1" width="100%" />
              </imageobject>
            </mediaobject>
          </figure>There are several things to notice on the screen shot above
        and that you can experiment in the view tester :</para>

        <itemizedlist>
          <listitem>
            <para>The columns have been refined to match the list of
            department's rendered properties.</para>
          </listitem>

          <listitem>
            <para>Mandatory columns have been marked with an asterisk.</para>
          </listitem>

          <listitem>
            <para>You can reorder and resize the columns as you wish.</para>
          </listitem>

          <listitem>
            <para>Some actions (duplicate, remove, cut and copy) may be
            applied on 1 selected item but also on a set of selected items; in
            that case, multiple selection is performed by maintaining the
            <keycode>CTRL</keycode> (increase selection with an individual
            item) or the <keycode>SHIFT</keycode> (range selection) and even
            both (increase selection with a range) key pressed when selecting
            the table rows.</para>
          </listitem>

          <listitem>
            <para>You can sort the lines of a table view on 1 column by
            clicking the column header and even on multiple columns (look at
            the address and city columns) by keeping the
            <keycode>CTRL</keycode> key pressed when clicking multiple column
            headers.</para>
          </listitem>

          <listitem>
            <para>The editable columns have been assigned an editor that
            matches their model; this includes associations LOV (see the
            editing manager cell above) and field controls and
            auto-completion.</para>
          </listitem>

          <listitem>
            <para>You might right-click on a selected line to open a context
            menu (not shown here) that will give you access to the same
            actions that are present in the tool bar.</para>
          </listitem>
        </itemizedlist>

        <para>To complete the organization view, we now need to manage the
        teams of a department.</para>
      </section>

      <section>
        <title>Nested master-detail views</title>

        <para>To handle the <code>Department</code> -&gt; <code>Team</code>
        relationship, we need to add another collection view backed by the 1-N
        association. The idea is to append this table view at the bottom of
        the previous one, using a new split view. Based on what we've already
        achieved, this is quite straight forward except for a slight but
        tricky difference : the teams to be displayed by the new table view
        are not directly related to the company but to the
        <emphasis>selected</emphasis> department in the intermediate
        department table view. So we need to instruct
        <trademark>D2S</trademark> that we want this nested master-detail
        behaviour.</para>

        <para>Let's first describe the teams collection view; for the sake of
        the tutorial, we will refine the teams displayed columns on the view
        itself instead of globally configuring the rendered properties of the
        team entity :<programlisting language="xml">&lt;bean
  id="Department-teams.table"
  parent="decoratedView"
  class="com.d2s.framework.view.descriptor.basic.BasicTableViewDescriptor"&gt;
  &lt;property
    name="modelDescriptor"
    ref="Department-teams" /&gt;
  &lt;property
    name="actionMap"
    ref="masterDetailActionMap" /&gt;
  &lt;property name="columnViewDescriptors"&gt; <co id="columnViewDescriptors" />
    &lt;list&gt;
      &lt;bean
        class="com.d2s.framework.view.descriptor.basic.BasicSubviewDescriptor"&gt;
        &lt;property
          name="name"
          value="ouId" /&gt;
      &lt;/bean&gt;
      &lt;bean
        class="com.d2s.framework.view.descriptor.basic.BasicSubviewDescriptor"&gt;
        &lt;property
          name="name"
          value="name" /&gt;
      &lt;/bean&gt;
      &lt;bean
        class="com.d2s.framework.view.descriptor.basic.BasicSubviewDescriptor"&gt;
        &lt;property
          name="name"
          value="manager" /&gt;
      &lt;/bean&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting></para>

        <para><calloutlist>
            <callout arearefs="columnViewDescriptors">
              <para>We setup the ordered list of columns we want to display on
              the teams table.</para>
            </callout>
          </calloutlist>This table view definition is strictly identical to
        the previous department view. We now need to assemble the
        <code>Company-departments.table</code> and the new
        <code>Department-teams.table</code> into a split view and tell
        <trademark>D2S</trademark> to drive the teams table content with the
        departments table selection :</para>

        <para><programlisting language="xml">&lt;bean
  id="Departments.and.teams.view"
  class="com.d2s.framework.view.descriptor.basic.BasicSplitViewDescriptor"&gt; <co
              id="Departments.and.teams.view" />
  &lt;property
    name="modelDescriptor"
    ref="Company" /&gt;
  &lt;property
    name="leftTopViewDescriptor"
    ref="Company-departments.table" /&gt; <co id="Company-departments.table" />
  &lt;property
    name="rightBottomViewDescriptor"
    ref="Department-teams.table" /&gt; <co id="Department-teams.table" />
  &lt;property
    name="masterDetail"
    value="true" /&gt; <co id="masterDetail" />
&lt;/bean&gt;</programlisting><calloutlist>
            <callout arearefs="Departments.and.teams.view">
              <para>We declare a new split view.</para>
            </callout>

            <callout arearefs="Company-departments.table">
              <para>We make the departments table view the top part of the
              view.</para>
            </callout>

            <callout arearefs="Department-teams.table">
              <para>We make the teams table view the top part of the
              view.</para>
            </callout>

            <callout arearefs="masterDetail">
              <para>We declare this composite view a master-detail view for
              <trademark>D2S</trademark> to track the departments
              selection.</para>
            </callout>
          </calloutlist>The crucial part of the previous definition is the use
        of the <code>masterDetail</code> attribute. It tells the framework
        that the sub-views we are composing are not straightly backed by
        properties of the master model, but each one will be driven by some
        kind of selection in the previous one. Note that this attribute is
        available on all composite views. Although some types of composite
        views are more adapted to master-detail relationships (the split view
        for example), you might very well decide to present arbitrary deep
        nested master-detail views in any kind of composite view (a tab view
        for example; in this case, each tab will be a detail of the previous
        one).</para>

        <para>Then, we need to refactor the
        <code>Company.organization.view</code> to substitute the current
        departments table view by our new
        <code>Departments.and.teams.view</code> :</para>

        <para><programlisting language="xml">&lt;bean
  id="Company.organization.view"
  class="com.d2s.framework.view.descriptor.basic.BasicSplitViewDescriptor"&gt;
  &lt;property
    name="modelDescriptor"
    ref="Company" /&gt;
  &lt;property
    name="leftTopViewDescriptor"
    ref="Company.tab.pane" /&gt;
  &lt;property
    name="rightBottomViewDescriptor"
    ref="Departments.and.teams.view" /&gt; <co id="Bottom.reworked" />
&lt;/bean&gt;</programlisting><calloutlist>
            <callout arearefs="Bottom.reworked">
              <para>We assign the departments and teams master-detail view as
              being now the bottom part of the company organization
              view.</para>
            </callout>
          </calloutlist>After adding some new translations and icons for the
        team entity, we can relaunch the view tester and obtain the following
        screen where you can fully manage the departments of a company and the
        teams of a department :</para>

        <para><figure>
            <title>The company, departments and teams view</title>

            <mediaobject>
              <imageobject>
                <imagedata align="center" contentdepth="60%"
                           fileref="../images/Company.organization.view_reworked_3.jpg"
                           scalefit="1" width="100%" />
              </imageobject>
            </mediaobject>
          </figure>Although we have already designed a fairly usable GUI, you
        might want to go one step further by presenting to the end-user a
        hierarchical tree view of the organization. This is what we are going
        to achieve in the next section.</para>
      </section>
    </section>

    <section>
      <title>Tree views</title>

      <para>Tree views are certainly the most complicated but also the most
      intuitive type of view to display and manage a structured model. Anyone
      who ever tried to build a truly MVC aware GUI using trees knows that
      there are many caveats to avoid. <trademark>D2S</trademark> drastically
      simplifies getting a tree view up and running while keeping its original
      description centric philosophy.</para>

      <section>
        <title>Simple tree levels</title>

        <para>Let's consider our next objective as inserting a new tab in the
        previous company view that shows the company structure in a tree view.
        Describing a tree view is a matter of describing each tree level and
        assembling them. To describe the company organization tree, we are
        going to declare :</para>

        <itemizedlist>
          <listitem>
            <para>1 tree view : <code>Company.tree</code>.</para>
          </listitem>

          <listitem>
            <para>1 tree level for the <code>Company</code> -&gt;
            <code>Department</code> 1-N relationship :
            <code>Company-departments.subtree</code> that will be the first
            child tree level in the company tree.</para>
          </listitem>

          <listitem>
            <para>1 tree level for the <code>Department</code> -&gt;
            <code>Team</code> 1-N relationship :
            <code>Department-teams.subtree</code> that will be the child tree
            level of the previous one.</para>
          </listitem>
        </itemizedlist>

        <para>Look at the following XML fragment :</para>

        <para><programlisting language="xml">&lt;bean
  id="Department-teams.subtree"
  class="com.d2s.framework.view.descriptor.basic.BasicSimpleTreeLevelDescriptor"&gt; <co
              id="BasicSimpleTreeLevelDescriptor" />
  &lt;property name="nodeGroupDescriptor"&gt;
    &lt;bean
      class="com.d2s.framework.view.descriptor.basic.BasicListViewDescriptor"&gt; <co
              id="nodeGroupDescriptor" />
      &lt;property
        name="modelDescriptor"
        ref="Department-teams" /&gt; <co id="Department-teams" />
      &lt;property
        name="actionMap"
        ref="masterDetailActionMap" /&gt; <co id="actionMap" />
      &lt;property
        name="renderedProperty"
        value="ouId" /&gt; <co id="renderedProperty" />
    &lt;/bean&gt;
  &lt;/property&gt;
&lt;/bean&gt;

&lt;bean
  id="Company-departments.subtree"
  class="com.d2s.framework.view.descriptor.basic.BasicSimpleTreeLevelDescriptor"&gt;
  &lt;property name="nodeGroupDescriptor"&gt;
    &lt;bean
      class="com.d2s.framework.view.descriptor.basic.BasicListViewDescriptor"&gt;
      &lt;property
        name="modelDescriptor"
        ref="Company-departments" /&gt;
      &lt;property
        name="actionMap"
        ref="masterDetailActionMap" /&gt;
      &lt;property
        name="renderedProperty"
        value="ouId" /&gt;
    &lt;/bean&gt;
  &lt;/property&gt;
  &lt;property name="childDescriptor"&gt;
    &lt;ref local="Department-teams.subtree" /&gt; <co id="childDescriptor" />
  &lt;/property&gt;
&lt;/bean&gt;

&lt;bean
  id="Company.tree"
  class="com.d2s.framework.view.descriptor.basic.BasicTreeViewDescriptor"&gt; <co
              id="BasicTreeViewDescriptor" />
  &lt;property
    name="modelDescriptor"
    ref="Company" /&gt;
  &lt;property
    name="renderedProperty"
    value="name" /&gt;
  &lt;property
    name="childDescriptor"
    ref="Company-departments.subtree" /&gt; <co id="childDescriptor2" />
  &lt;property
    name="iconImageURL"
    value="classpath:com/d2s/framework/hrsample/images/structure-48x48.png" /&gt; <co
              id="Company.tree.icon" />
&lt;/bean&gt;</programlisting><calloutlist>
            <callout arearefs="BasicSimpleTreeLevelDescriptor">
              <para>We declare a simple tree level that may hold only one
              child tree level; this one is a terminal level, so it doesn't
              hold any.</para>
            </callout>

            <callout arearefs="nodeGroupDescriptor">
              <para>Each simple tree level references a list view descriptor
              (the same type of descriptor we may use for list views) that is
              backed by the collection end of a relationship through the use
              of its <code>nodeGroupDescriptor</code> property.</para>
            </callout>

            <callout arearefs="Department-teams">
              <para>This simple tree level is backed by the
              <code>Department</code> -&gt; <code>Team</code> relationship
              since it will display the teams of a department node.</para>
            </callout>

            <callout arearefs="actionMap">
              <para>As for plain views, we can assign an action map to a
              simple tree level through the action map of its referenced list
              view descriptor. The registered action map will be accessible
              from a contextual menu. Here, we assign the same master-detail
              action map as we used for the table views.</para>
            </callout>

            <callout arearefs="renderedProperty">
              <para>Each node of a simple tree level - here it's a team - must
              be rendered by one of its property. When not set, the rendering
              property is chosen by the backing component descriptor itself.
              We want the <code>ouId</code> of a team to be displayed.</para>
            </callout>

            <callout arearefs="childDescriptor">
              <para>This tree level descriptor, while still a simple tree
              level descriptor, differs from the previous one by the fact that
              is not a terminal level; so we assign its child descriptor as
              being the <code>Department-teams.subtree</code>
              descriptor.</para>
            </callout>

            <callout arearefs="BasicTreeViewDescriptor">
              <para>The tree view descriptor itself. It may be composed
              anywhere in the GUI.</para>
            </callout>

            <callout arearefs="childDescriptor2">
              <para>We set the <code>Company-departments.subtree</code> as
              being the first child tree level of the tree.</para>
            </callout>

            <callout arearefs="Company.tree.icon">
              <para>The default icon used to display this view would be the
              icon declared in the company entity. Let's change it so that we
              have a different icon once we install the view in the
              tab.</para>
            </callout>
          </calloutlist>The final step to reach the objective is to install
        the company tree view in a new tab of the company tab view. We do this
        by modifying the <code>Company.tab.pane</code> view as below :</para>

        <para><programlisting language="xml">&lt;bean
  id="Company.tab.pane"
  class="com.d2s.framework.view.descriptor.basic.BasicTabViewDescriptor"&gt;
  ...
  &lt;property name="viewDescriptors"&gt;
    &lt;list&gt;
      ...
      &lt;ref local="Company.tree" /&gt; <co id="Company.tree" />
      ...
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting><calloutlist>
            <callout arearefs="Company.tree">
              <para>We declare another tab in the tab view.</para>
            </callout>
          </calloutlist>We can now test the result.</para>

        <para><figure>
            <title>The company structure as a tree view</title>

            <mediaobject>
              <imageobject>
                <imagedata align="center" contentdepth="60%"
                           fileref="../images/Company.organization.view_tree.jpg"
                           scalefit="1" width="100%" />
              </imageobject>
            </mediaobject>
          </figure>Play around with the tree and with the tables. You will see
        that everything is always kept synchronized; we have a true MVC
        architecture.</para>
      </section>

      <section>
        <title>Composite tree levels</title>

        <para>There are situations where simple tree levels are just not
        enough to define complex tree structures. Imagine that you want to
        display, under each team, a subtree for the projects managed by a team
        and a subtree for the team members.</para>

        <para><trademark>D2S</trademark> allows you aggregate the 2 simple
        tree levels (projects and team members) into a composite tree level
        and make this composite tree level the child level of the team tree
        level.</para>
      </section>
    </section>

    <section>
      <title>Other types of views</title>

      <para><trademark>D2S</trademark> offers many other types of views to
      build arbitrarily complex views to enhance the user experience. We won't
      describe theme in detail in this tutorial but you can refer to the view
      descriptor reference section for a complete description. Fell free also
      to browse the complete sources of the HR sample application while
      running it to see them in action. Just remember that all the other
      standard view descriptors follow the exact same principles we have
      discovered in this section : assemble the descriptors to design what you
      need and let the framework work for you.</para>

      <para>It's time now to get our application really up and running.</para>
    </section>
  </section>

  <section>
    <title>Wiring the application</title>

    <para>As we saw it at the beginning of this tutorial, a
    <trademark>D2S</trademark> based application is cleanly organized into 3
    separate layers :</para>

    <orderedlist>
      <listitem>
        <para>The model layer which contains the rich domain business
        objects</para>
      </listitem>

      <listitem>
        <para>The backend layer which is responsible for handling the backend
        state and operations providing :</para>

        <itemizedlist>
          <listitem>
            <para>domain business objects manipulation and persistence</para>
          </listitem>

          <listitem>
            <para>transaction management</para>
          </listitem>

          <listitem>
            <para>rich application session that handles domain state, long
            running user transactions (independent from actual technical
            transactions and persistence) and user management (identification,
            credentials, authorizations, ...)</para>
          </listitem>

          <listitem>
            <para>actions backend part (domain services triggering, unit of
            work for handling in-memory transaction-aware domain state)</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>The frontend layer which is responsible for handling the user
        interactions :</para>

        <itemizedlist>
          <listitem>
            <para>user log in</para>
          </listitem>

          <listitem>
            <para>application starting and access to the various registered
            modules</para>
          </listitem>

          <listitem>
            <para>construction and display of the views</para>
          </listitem>

          <listitem>
            <para>actions frontend part (wizards, success and error
            notifications, decisions, ...)</para>
          </listitem>
        </itemizedlist>
      </listitem>
    </orderedlist>

    <para>We have already covered in details the model layer in this tutorial.
    This section will address the backend and frontend layers.</para>

    <section>
      <title>Configuring the backend layer</title>

      <para>The backend layer is organized around the backend controller. The
      backend controller is the conductor of all backend operations. As of
      now, <trademark>D2S</trademark> provides one concrete implementation of
      a backend controller : the Hibernate backend controller. This
      implementation provides all the backend management described above using
      hibernate and the hibernate spring stack (using hibernate and
      transaction templates). We will see later on how the spring hibernate
      stack is used when dealing with actions.</para>

      <para>To materialize and further configure the application backend,
      let's create 2 new spring configuration files (listings below omit the
      standard XML spring headers) :</para>

      <orderedlist>
        <listitem>
          <para><filename>hrsample-backend.xml</filename> that will logically
          go into the <code>com.d2s.framework.hrsample.backend</code> package
          and will hold all the description of the backend.</para>
        </listitem>

        <listitem>
          <para><filename>config.xml</filename> that we will put in the
          <code>com.d2s.framework.hrsample</code> package and that will hold
          all the specific configuration related to a deployment
          environment.</para>
        </listitem>
      </orderedlist>

      <para>As always, getting the hibernate backend controller into the
      application will be a matter of configuration. The first part will be
      achieved by updating the <filename>beanRefFactory.xml</filename> with a
      new context entry (named <code>hrsample-swing-context</code>) for the
      application to run with swing and hibernate with the hibernate
      controller installed :</para>

      <para><programlisting language="xml">&lt;bean
  id="hrsample-model-context"
  class="org.springframework.context.support.ClassPathXmlApplicationContext"
  lazy-init="true"&gt;
  ...
&lt;/bean&gt;

&lt;bean
  id="hrsample-viewtester-context"
  class="org.springframework.context.support.ClassPathXmlApplicationContext"
  lazy-init="true"&gt;
  ...
&lt;/bean&gt;

&lt;bean
  id="hrsample-swing-context"
  class="org.springframework.context.support.ClassPathXmlApplicationContext"
  lazy-init="true"&gt;
  &lt;constructor-arg&gt;
    &lt;list&gt;
      &lt;value&gt;com/d2s/framework/application/commons.xml&lt;/value&gt;
      &lt;value&gt;com/d2s/framework/application/backend/persistence/hibernate/commons-hibernate.xml&lt;/value&gt; <co
            id="commons-hibernate.xml" />
      &lt;value&gt;com/d2s/framework/application/frontend/commons-frontend.xml&lt;/value&gt;
      &lt;value&gt;com/d2s/framework/application/frontend/swing/commons-swing.xml&lt;/value&gt;
      &lt;value&gt;com/d2s/framework/hrsample/model/hrsample-model.xml&lt;/value&gt;
      &lt;value&gt;com/d2s/framework/hrsample/backend/hrsample-backend.xml&lt;/value&gt; <co
            id="hrsample-backend.xml" />
      &lt;value&gt;com/d2s/framework/hrsample/frontend/hrsample-frontend.xml&lt;/value&gt;
      &lt;value&gt;com/d2s/framework/hrsample/config.xml&lt;/value&gt; <co
            id="config.xml" />
    &lt;/list&gt;
  &lt;/constructor-arg&gt;
&lt;/bean&gt;</programlisting><calloutlist>
          <callout arearefs="commons-hibernate.xml">
            <para>This is the standard <trademark>D2S</trademark> spring
            configuration file to bring an hibernate powered backend to our
            application.</para>
          </callout>

          <callout arearefs="hrsample-backend.xml">
            <para>The backend spring configuration file that we have created
            above.</para>
          </callout>

          <callout arearefs="config.xml">
            <para>The environment configuration file that we also have created
            above.</para>
          </callout>
        </calloutlist></para>

      <para>As of now, we will keep the
      <filename>hrsample-backend.xml</filename> configuration file
      empty.</para>

      <para>On the other hand, let's complete the
      <filename>config.xml</filename> file for our development environment
      like the following :</para>

      <para><programlisting language="xml">&lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt; <co
            id="dataSource" />
  &lt;property name="driverClassName" value="org.hsqldb.jdbcDriver" /&gt; <co
            id="dataSource-params" />
  &lt;property name="url" value="jdbc:hsqldb:mem:hrsample" /&gt; <co
            id="hsqldbmem" />
  &lt;property name="username" value="sa" /&gt;
  &lt;property name="password" value="" /&gt;
&lt;/bean&gt;

&lt;bean id="hibernateSessionFactory" parent="abstractHibernateSessionFactory"&gt; <co
            id="hibernateSessionFactory" />
  &lt;property name="hibernateProperties"&gt;
    &lt;props&gt;
      &lt;prop key="hibernate.query.substitutions"&gt;true 1, false 0, yes 'Y', no 'N'&lt;/prop&gt;
      &lt;prop key="hibernate.dialect"&gt;org.hibernate.dialect.HSQLDialect&lt;/prop&gt;
      &lt;prop key="hibernate.order_updates"&gt;true&lt;/prop&gt;
      &lt;prop key="hibernate.max_fetch_depth"&gt;1&lt;/prop&gt;
      &lt;prop key="hibernate.default_batch_fetch_size"&gt;8&lt;/prop&gt;
      &lt;prop key="hibernate.jdbc.batch_versioned_data"&gt;true&lt;/prop&gt;
      &lt;prop key="hibernate.jdbc.use_streams_for_binary"&gt;true&lt;/prop&gt;
      &lt;prop key="hibernate.cache.region_prefix"&gt;hibernate.test&lt;/prop&gt;
      &lt;prop key="hibernate.cache.provider_class"&gt;org.hibernate.cache.HashtableCacheProvider&lt;/prop&gt;
      &lt;prop key="hibernate.hbm2ddl.auto"&gt;update&lt;/prop&gt; <co
            id="hbm2ddl" />
    &lt;/props&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting><calloutlist>
          <callout arearefs="dataSource">
            <para>We configure the data source that will be used in this
            environment.</para>
          </callout>

          <callout arearefs="dataSource-params">
            <para>In the development phase, we will use the well known HSQL DB
            in-memory database. HSQL DB will freshly start every-time the
            application itself starts and instantiate the data source.</para>
          </callout>

          <callout arearefs="hsqldbmem">
            <para>We configures the JDBC URL to use the in-memory
            database.</para>
          </callout>

          <callout arearefs="hibernateSessionFactory">
            <para>We configure the hibernate session factory with sensible
            values inheriting from the one brought by the hibernate standard
            configuration. For a complete reference of the meaning of the
            different parameters, please either refer to the hibernate or
            spring reference documentation. The most important here is that we
            tell hibernate to talk to the database using the HSQL DB
            dialect.</para>
          </callout>

          <callout arearefs="hbm2ddl">
            <para>Last but not least, since we configure a development
            environment, we tell hibernate to update (in our case create) the
            DB schema when starting so that our in memory HSQL DB gets
            populated with a fresh, empty, domain-synchronized schema.</para>
          </callout>
        </calloutlist>With this little configuration steps, we now have a
      fully functional hibernate aware backend relying on our domain model.
      The next phase consist in setting up the configuration for the
      frontend.</para>
    </section>

    <section>
      <title>Configuring the frontend layer</title>

      <para>In this section, we will go through the different steps to finally
      have our application up and running.</para>

      <para>The minimal frontend configuration requires the definition of the
      frontend controller. Although the backend controller is quite generic
      and requires no special parametrization (the default implementation
      brought to you by the <filename>commons-hibernate.xml</filename> is
      usable as-is) most of the application assembling is done in the
      front-end controller. For the sake of simplicity, we will configure the
      frontend controller directly in the existing
      <filename>hrsample-frontend.xml</filename> configuration file; but you
      are free to split all the configuration files in smaller pieces (for
      instance one separate piece for the views) but then, don't forget to
      update the various context entries in the
      <filename>beanRefFactory.xml</filename> bootstrap configuration
      file.</para>

      <para>So lets add our front controller definition :</para>

      <para><programlisting language="xml">&lt;bean
  id="applicationFrontController"
  parent="frontController"
  scope="prototype"&gt; <co id="applicationFrontController" />
  &lt;property
    name="name"
    value="hrsample.name" /&gt; <co id="hrsample.name" />
  &lt;property
    name="iconImageURL"
    value="classpath:com/d2s/framework/hrsample/images/people-48x48.png" /&gt; <co
            id="hrsample.iconImageURL" />
  &lt;property
    name="modulesMenuIconImageUrl"
    value="classpath:com/d2s/framework/hrsample/images/modules-48x48.png" /&gt; <co
            id="modulesMenuIconImageUrl" />
&lt;/bean&gt;</programlisting><calloutlist>
          <callout arearefs="applicationFrontController">
            <para>We declare our application frontend controller to inherit
            from the standard concrete frontend controller. In our case, since
            we imported the <filename>commons-swing.xml</filename> standard
            configuration file for swing, our controller will be a swing
            controller. Switching to another presentation technology (ULC or
            AJAX as of this writing) will then just be a matter of changing
            the imported configuration file
            (<filename>commons-ulc.xml</filename> for instance) in the
            <filename>beanRefFactory.xml</filename> file.</para>
          </callout>

          <callout arearefs="hrsample.name">
            <para>We define the name (in fact the I18N key) of the controller,
            or more generally of the application. It will be used as the frame
            title in the case of the swing controller.</para>
          </callout>

          <callout arearefs="hrsample.iconImageURL">
            <para>We define the icon of the controller, or more generally of
            the application. It will be used as the frame icon in the case of
            the swing controller.</para>
          </callout>

          <callout arearefs="modulesMenuIconImageUrl">
            <para>We define the icon of the menu used to launch the different
            application modules (but we haven't talked about modules
            yet...).</para>
          </callout>
        </calloutlist>That's it for the minimal frontend configuration.</para>
    </section>

    <section>
      <title>Starting up the application</title>

      <para>To be able to launch the application, we need a startup class. In
      <trademark>D2S</trademark>, the startup class configures the spring
      context to be used when starting the application. The actual startup is
      performed by a generic launcher depending on the presentation technology
      used. For instance, the swing generic launcher is
      <code>com.d2s.framework.application.launch.swing.SwingLauncher</code>;
      this is the one we are going to use now. So let's create our swing
      startup class. We will name it <code>SwingHrSampleStartup</code> and
      create it in a new <code>com.d2s.framework.hrsample.startup</code> java
      package :</para>

      <para><programlisting language="xml">package com.d2s.framework.hrsample.startup;

import com.d2s.framework.application.frontend.startup.swing.SwingStartup;

/**
 * Swing HR sample startup class.
 */
public class SwingHrSampleStartup extends SwingStartup { <co
            id="SwingHrSampleStartup" />

  /**
   * Returns the "hrsample-swing-context" value.
   * &lt;p&gt;
   * {@inheritDoc}
   */
  @Override
  protected String getApplicationContextKey() {
    return "hrsample-swing-context"; <co id="getApplicationContextKey" />
  }
}</programlisting></para>

      <para><calloutlist>
          <callout arearefs="SwingHrSampleStartup">
            <para>We inherit from <code>SwingStartup</code> since we are
            starting a swing application.</para>
          </callout>

          <callout arearefs="getApplicationContextKey">
            <para>Our swing application will use the
            <code>hrsample-swing-context</code> entry we defined in the
            bootstrap <filename>beanRefFactory.xml</filename> file.</para>
          </callout>
        </calloutlist>We are now ready to launch our application for the first
      time. Issue the following command with the appropriate classpath
      :</para>

      <para><code>java
      com.d2s.framework.application.launch.swing.SwingLauncher
      -applicationClass
      com.d2s.framework.hrsample.startup.SwingHrSampleStartup -splash
      classpath:com/d2s/framework/hrsample/images/logo-small.png</code></para>

      <para>You should have a splash screen popping up and soon after the
      following MDI frame (here with a substance look and feel and a French
      locale) :</para>

      <para><figure>
          <title>The first application run</title>

          <mediaobject>
            <imageobject>
              <imagedata align="center" contentdepth="60%"
                         fileref="../images/AppLaunch.jpg" scalefit="1"
                         width="100%" />
            </imageobject>
          </mediaobject>
        </figure></para>

      <para>Of course, this is a very basic launch for a pretty useless
      application... To improve it, we will first secure it with a login
      module and then create some application modules.</para>
    </section>

    <section>
      <title>Securing the application access</title>

      <para>Securing an application is a matter of handling :</para>

      <itemizedlist>
        <listitem>
          <para>Authentication (is the user the one he pretends to be
          ?).</para>
        </listitem>

        <listitem>
          <para>Authorization (is the user granted access to what he's trying
          to achieve ?).</para>
        </listitem>
      </itemizedlist>

      <para>Both of these topics are extensively covered by the
      <trademark>D2S</trademark> framework. This chapter covers the
      authentication part.</para>

      <para>Authentication in a <trademark>D2S</trademark> application relies
      on JAAS (Java Authentication and Authorization Service). We will not go
      into details about JAAS since there are excellent tutorials on the web
      (<ulink
      url="http://java.sun.com/j2se/1.5.0/docs/guide/security/jaas/tutorials/index.html">this
      one</ulink> for instance). <trademark>D2S</trademark> provides all the
      necessary plumbing to seamlessly integrate any JAAS login module and as
      of this writing, there are 2 login modules that come with the framework
      :</para>

      <itemizedlist>
        <listitem>
          <para>The development login module which does not require any
          backend and is perfectly suited for development.</para>
        </listitem>

        <listitem>
          <para>The ldap login module which authenticates the user against an
          LDAP directory.</para>
        </listitem>
      </itemizedlist>

      <para>You may find many other, freely available, JAAS login modules to
      meet your needs (JDBC, ascii encrypted file, ...). In this section, we
      will secure our application with the development login module but the
      exact same principles (except for the module configuration itself) can
      be applied for others.</para>

      <section>
        <title>Configuring the development login module</title>

        <para>As for any JAAS based login module, we will create a
        configuration file (here <filename>jaas.config</filename> that we will
        place in the root of our project) that we will later reference as a
        java system property (<code>java.security.auth.login.config</code>)
        when launching the application.</para>

        <para>Here is the <filename>jaas.config</filename> file explained
        :</para>

        <para><programlisting>/** Login Configuration for the HR sample application **/

hrsample-app { <co id="hrsample-app" />
   com.d2s.framework.security.auth.spi.DevelopmentLoginModule required <co
              id="DevelopmentLoginModule" />
       user=demo <co id="user" />
       password=demo <co id="password" />
       roles=admin <co id="roles" />
       custom.language=en; <co id="language" />
};</programlisting><calloutlist>
            <callout arearefs="hrsample-app">
              <para>The name of the login context that we use for the
              application.</para>
            </callout>

            <callout arearefs="DevelopmentLoginModule">
              <para>We reference the development login module class.</para>
            </callout>

            <callout arearefs="user">
              <para>The user name the development will check (here
              "demo").</para>
            </callout>

            <callout arearefs="password">
              <para>The user password the development will check (here
              "demo").</para>
            </callout>

            <callout arearefs="roles">
              <para>The comma-separated list of roles (profiles) the logged-in
              user will be assigned (here "admin"). These roles will be
              checked against when dealing with authorizations.</para>
            </callout>

            <callout arearefs="language">
              <para>Any custom property we want to store in the user
              principal; these properties are kept in a map. Here, we store
              the custom <code>language</code> property as being English. the
              <code>language</code> property is a well-known property that
              will be used by the front-end and back-end controllers to apply
              the correct locale for GUI and messages.</para>
            </callout>
          </calloutlist>As you can see, this login module is absolutely not
        suited for production purpose but it is perfect for development since
        you will be able to assign different locales to the logged-in user
        (and thus test for the I18N of the application), or vary the granted
        roles (and thus test for the authorization policies you have set up).
        Moreover, you can feed the user principal with an arbitrary list of
        custom properties your application may need to refer to.</para>

        <para>Of course, other login modules will fetch everything from a
        persistent store and configuring them will be a matter of customizing
        how the user password will be checked and how the user data will be
        retrieved. But the key point is that changing the authorization method
        will just be a matter of changing the <filename>jaas.config</filename>
        file; all the other steps we will go through know will remain
        unchanged.</para>
      </section>

      <section>
        <title>Declaring the login context</title>

        <para>The next and final step to activate the login module in our
        application is to declare the login context created above in the
        front-end controller :</para>

        <para><programlisting language="xml">  &lt;bean
    id="applicationFrontController"
    parent="frontController"
    scope="prototype"&gt;
    ...
    &lt;property
      name="loginContextName"
      value="hrsample-app" /&gt; <co id="loginContextName" />
   &lt;/bean&gt;</programlisting><calloutlist>
            <callout arearefs="loginContextName">
              <para>We configure the controller to use the
              <code>hrsample-app</code> login context.</para>
            </callout>
          </calloutlist>When relaunching the application with the java system
        property
        <code>-Djava.security.auth.login.config=/path/to/jaas.config</code>, a
        login dialog appears and once the user has logged-in, the entire
        application is translated in its locale; notice that until the user
        has actually logged in, the client machine default locale
        applies.</para>

        <para><figure>
            <title>The login dialog on a French client machine</title>

            <mediaobject>
              <imageobject>
                <imagedata align="center" contentdepth="60%"
                           fileref="../images/LoginDialog.jpg" scalefit="1"
                           width="100%" />
              </imageobject>
            </mediaobject>
          </figure><figure>
            <title>The application main window with an English logged-in
            user</title>

            <mediaobject>
              <imageobject>
                <imagedata align="center" contentdepth="60%"
                           fileref="../images/AppLaunch_en.jpg" scalefit="1"
                           width="100%" />
              </imageobject>
            </mediaobject>
          </figure>We will see further how to take care of the profiles
        (roles) authorizations and how the framework will handle it for you
        with very little configuration. But before getting there, we need to
        install some application modules.</para>
      </section>
    </section>
  </section>

  <section>
    <title>Creating and registering application modules</title>

    <para></para>
  </section>
</chapter>